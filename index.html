<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <link rel="manifest" href="manifest.webmanifest" type="application/manifest+json">
  <meta name="theme-color" content="#000000">
  <link rel="icon" href="icon-192.png">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="light dark" />
  <title>lexi — офлайн-тренажёр</title>

  <!-- Inline CSS (вставляется build.sh) + базовый безопасный фолбэк -->
  <style>
    /* ===== INLINE CSS START ===== */
:root{ --fg:#111; --muted:#666; --bg:#fff; --tile:#f5f5f7; --tile-hover:#ececf0; --border:#e5e7eb; --bad:#ef4444;}*{box-sizing:border-box}html,body{height:100%}body{margin:0;font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; color:var(--fg); background:var(--bg);}.app{max-width:860px;margin:0 auto;padding:12px 10px 24px}.app__top{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px 10px;margin-bottom:8px}.progress{font-weight:800}.q-headline{text-align:center;font-weight:800;font-size:18px;line-height:1.2;letter-spacing:.01em;padding:2px 6px;border-radius:10px}.top-actions{display:flex;gap:8px;justify-self:end}.btn{background:transparent;border:1px solid var(--border);border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600;white-space:nowrap}.btn:hover{background:#f6f7f9}.btn--primary{border-color:#808080;background:#ffffff}.btn--ghost{border-color:var(--border);background:transparent}.zones{display:grid;grid-template-columns:1fr;gap:10px;margin-top:8px}@media (min-width: 960px){ .zones{grid-template-columns:1fr 1fr 1fr} }.zone{border:1px solid var(--border); border-radius:12px; padding:10px 10px 12px; min-height:190px; display:flex; flex-direction:column}.zone__title{font-size:13px; letter-spacing:.02em; color:var(--muted); margin-bottom:6px; display:flex; align-items:center; gap:8px}.zone__body{flex:1; display:flex; flex-direction:column; gap:10px}.maskline{ text-align:center; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-weight:800; }.vlist{display:flex; flex-direction:column; gap:8px; min-width:64px}.vlist--center{align-self:center}.tile{ background:var(--tile); border-radius:12px; padding:12px 14px; user-select:none; cursor:pointer; border:1px solid transparent; text-align:center; font-weight:800; letter-spacing:.02em;}.tile:hover{background:var(--tile-hover)}.zone--locked{opacity:.55; filter:grayscale(.2)}.zone--fixed {background:linear-gradient(0deg, rgba(250,250,250,.06), rgba(250,250,250,.02)); border-color:#c7ead5}.badge{display:inline-block;border-radius:999px;padding:6px 10px;background:#ffffff;border:1px solid #808080;font-weight:800}.placeholder{flex:1; display:flex; align-items:center; justify-content:center; border:1px dashed #cbd5e1; color:var(--muted); border-radius:8px; font-size:14px;}.wordlist{display:flex; flex-direction:column; gap:6px; width:100%}.card__footer{display:flex; justify-content:flex-start; margin-top:10px}.result{border:1px solid var(--border); border-radius:12px; padding:16px; background:#fafafa}.result h2{margin:.2em 0 .4em 0}.tap-next{cursor:pointer}.result__actions{display:flex; gap:10px; margin-top:8px; flex-wrap:wrap}.mistake{border:1px solid var(--border); border-radius:12px; padding:16px; background:#fff; cursor:pointer}.mistake__row{display:flex; gap:12px; align-items:flex-start; padding:8px 0; border-bottom:1px dashed var(--border)}.mistake__row:last-child{border-bottom:none}.mistake__title{min-width:92px; color:var(--muted)}.mistake__vals{display:flex; gap:10px; flex-wrap:wrap}.mistake__val{border-radius:999px; padding:6px 10px; border:1px solid var(--border)}.mistake__val.good{background:#ffffff; border-color:#808080}.mistake__val.bad{background:#fee2e2; border-color:#fecaca}.mistake__hint{color:var(--muted); text-align:center; margin-top:8px; font-size:13px}.empty{text-align:center; padding-top:14vh}.empty__sub{color:var(--muted)}.dbadd{--bg:#f6f8fb;--card:#fff;--ink:#0a1428;--muted:#8c94a3;--line:#e6e8f0;--warn:#e11d48;--chip:#eef1f6; font:14px/1.35 Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--ink)}@media (prefers-color-scheme: dark){ .dbadd{--bg:#0f1117;--card:#151821;--ink:#e5e7eb;--muted:#9aa3b2;--line:#262b39;--chip:#1b2130;--warn:#fb7185}}.dbadd .wrap{max-width:560px;margin:0 auto;min-height:100vh;background:var(--bg);padding:12px}.dbadd .head{display:flex;align-items:center;gap:12px}.dbadd .back{min-width:48px;min-height:40px;border:0;border-radius:12px;background:var(--chip);color:var(--ink);font-weight:900}.dbadd .ttl{font-size:22px;font-weight:900;letter-spacing:.2px}.dbadd .card{background:var(--card);border-radius:16px;padding:16px;margin-top:12px;box-shadow:0 10px 30px rgba(0,0,0,.06)}.dbadd .hint{color:var(--muted);margin-bottom:8px;white-space:pre-line}.dbadd .ta{width:100%;min-height:120px;border:1px solid var(--line);border-radius:12px;background:var(--card); resize:vertical;padding:12px;color:var(--ink);font-weight:600}.dbadd .err{margin-top:10px;color:var(--warn);font-weight:800;display:none}.dbadd .preview{margin-top:12px;background:var(--chip);border-radius:12px;padding:10px 12px}.dbadd .row{display:flex;gap:10px;margin-top:16px}.dbadd .btn{flex:1;min-height:48px;border:0;border-radius:14px;font-weight:900}.dbadd .btn.primary{background:#2563eb;color:#fff}.dbadd .btn.ghost{background:var(--chip);color:var(--ink)}.dbadd .btn:disabled{opacity:.5}.dbedit{ --bg:#f6f8fb; --card:#fff; --ink:#0a1428; --muted:#8c94a3; --line:#e6e8f0; --warn:#e11d48; --chip:#eef1f6; font:14px/1.35 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--ink); }@media (prefers-color-scheme: dark){ .dbedit{ --bg:#0f1117; --card:#151821; --ink:#e5e7eb; --muted:#9aa3b2; --line:#262b39; --chip:#1b2130; --warn:#fb7185; }}.dbedit .wrap{ max-width:560px; margin:0 auto; min-height:100vh; background:var(--bg); padding:12px; }.dbedit .head{ display:flex; align-items:center; gap:12px; }.dbedit .back{ min-width:48px; min-height:40px; border:0; border-radius:12px; background:var(--chip); color:var(--ink); font-weight:900; }.dbedit .ttl{ font-size:22px; font-weight:900; letter-spacing:.2px; }.dbedit .card{ background:var(--card); border-radius:16px; padding:16px; margin-top:12px; box-shadow:0 10px 30px rgba(0,0,0,.06); }.dbedit .hint{ color:var(--muted); margin-bottom:8px; }.dbedit .ta{ width:100%; min-height:120px; border:1px solid var(--line); border-radius:12px; background:var(--card); resize:vertical; padding:12px; color:var(--ink); font-weight:600; }.dbedit .err{ margin-top:10px; color:var(--warn); font-weight:800; }.dbedit .preview{ margin-top:12px; background:var(--chip); border-radius:12px; padding:10px 12px; }.dbedit .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:16px; }.dbedit .btn{ min-height:48px; border:0; border-radius:14px; font-weight:900; }.dbedit .btn.primary{ background:#16a34a; color:#fff; }.dbedit .btn.warn{ background:#ef4444; color:#fff; }.dbedit .btn.ghost{ background:var(--chip); color:var(--ink); }.dbedit .btn:disabled{ opacity:.5 }.dbl{ --bg:#f6f8fb; --card:#fff; --ink:#0a1428; --muted:#8c94a3; --line:#e6e8f0; --danger:#e11d48; --chip:#eef1f6; font:14px/1.35 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--ink); }@media (prefers-color-scheme: dark){ .dbl{ --bg:#0f1117; --card:#151821; --ink:#e5e7eb; --muted:#9aa3b2; --line:#262b39; --chip:#1b2130; --danger:#fb7185; }}.dbl .wrap{ max-width:560px; margin:0 auto; min-height:100vh; background:var(--bg); padding:12px 12px 24px; }.dbl .top{ display:flex; align-items:center; gap:12px; }.dbl .back{ min-width:48px; min-height:40px; border:0; border-radius:12px; background:var(--chip); color:var(--ink); font-weight:800; }.dbl .ttl{ font-size:22px; font-weight:900; letter-spacing:.2px; margin-left:8px; }.dbl .sub{ color:var(--muted); margin:2px 0 12px 56px; }.dbl .search{ margin:10px 0 10px; position:relative; }.dbl .search input{ width:100%; height:44px; border:1px solid var(--line); background:var(--card); border-radius:12px; padding:0 14px; color:var(--ink); font-weight:600;}.dbl .list{ margin-top:8px; display:flex; flex-direction:column; gap:10px; }.dbl .wipe{ display:flex; align-items:center; justify-content:flex-start; gap:10px; padding:12px 14px; border-radius:12px; cursor:pointer; background:var(--card); box-shadow:0 8px 20px rgba(0,0,0,.06); }.dbl .wipe .icon{ width:28px; height:28px; border-radius:8px; display:grid; place-items:center; background: color-mix(in srgb, var(--danger) 12%, transparent); color:var(--danger); font-weight:900; }.dbl .wipe .txt{ font-weight:900; color:var(--danger); }.dbl .wipe:active{ transform: translateY(1px); }.dbl .empty{ color:var(--muted); text-align:center; padding:24px 8px; }.ex{ font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color:#0a1428; }@media (prefers-color-scheme: dark){ .ex{ color:#e5e7eb; } }.ex{ --ex-island-bg: #F4F5F7; --ex-divider: rgba(0,0,0,.14); --ex-text: #0A1428;}@media (prefers-color-scheme: dark){ .ex{ --ex-island-bg: #111827; --ex-divider: rgba(255,255,255,.18); --ex-text: #E5E7EB; }}.ex .wrap{ width:100%; max-width:520px; margin:0 auto; padding:12px 12px 24px; }.ex .progress{ font-size:12px; opacity:.6; margin: 2px 2px 8px; }.ex h1{ margin:8px 0 8px; font-size:28px; line-height:1.2; letter-spacing:.3px; font-weight:900; text-transform:uppercase; text-align: center; padding-top: 1rem; padding-bottom: 1rem; }.ex .chips{ display:flex; flex-direction:column; gap:8px; margin: 12px 0 10px; }.ex .chip{ align-self:flex-start; min-width:180px; width: 100%; padding:10px 14px; border-radius:12px; background:#f7f8fb; box-shadow: 0 6px 14px rgba(0,0,0,.08); font-weight:800; }.ex .chip .sub{ display:block; color:#6b7280; font-weight:700; text-align:center; font-size:12px; margin-bottom:4px; }.ex .chip .subCon{ display:block; text-align:center; font-size:25px; font-family:monospace}@media (prefers-color-scheme: dark){ .ex .chip{ background:#111827; box-shadow: 0 6px 18px rgba(0,0,0,.45); } .ex .chip .sub{ color:#9ca3af; }}.ex .mount{ display:flex; justify-content:center; margin-top:12px; min-height:176px; }.ex .btn-back{ width:100%; margin: 22px 0 0; min-height:52px; border:0; border-radius:14px; font-weight:900; letter-spacing:.2px; background:#eef1f6; color:#0a1428; cursor:pointer;}.ex .btn-back:disabled{ opacity:.5; cursor:default; }@media (prefers-color-scheme: dark){ .ex .btn-back{ background:#1b2130; color:#e5e7eb; } }.hidden{ display:none !important; }.exres{--bg:#F7F8FA;--card:#FFF;--ink:#111318;--sub:#5B616E;--muted:#8C92A3; --primary:#1750FF;--bad:#D82D3F;--good:#16a34a;--chip:#EEF1F7;--border:#E6E8EE; --okBg:#E9F8F1;--okBr:#C8F0DF;--errBg:#FDECEF;--errBr:#F7C6CE; --cw:16px;--rowH:24px; font:14px/1.3 Inter, system-ui, Segoe UI, Roboto, Arial; color:var(--ink); }@media (prefers-color-scheme: dark){ .exres{--bg:#0f1117;--card:#151821;--ink:#e5e7eb;--sub:#b2b8c6;--muted:#9aa3b2;--border:#262b39; --chip:#1b2130;--okBg:#092f1e;--okBr:#155e43;--errBg:#2a1014;--errBr:#7a2c39;}}.exres .screen{max-width:520px;margin:0 auto;background:var(--bg);min-height:100vh}.exres .top{position:sticky;top:0;background:var(--card);display:flex;gap:12px;align-items:center;height:56px; padding:0 12px;border-bottom:1px solid var(--border);box-shadow:0 2px 6px rgba(0,0,0,.06);z-index:5}.exres .ttl{font-weight:800;font-size:18px}.exres .badge{display:inline-flex;align-items:center;gap:8px;border-radius:999px;height:30px;padding:0 10px;font-weight:700}.exres .bad{background:var(--errBg);color:var(--bad);outline:1px solid var(--errBr)}.exres .good{background:var(--okBg);color:var(--good);outline:1px solid var(--okBr)}.exres .btn{border:1px solid var(--border);border-radius:12px;height:32px;padding:0 12px;display:inline-flex;align-items:center; color:var(--primary);font-weight:700;background:transparent}.exres .card{background:var(--card);border-radius:16px;margin:16px; padding:16px;box-shadow:0 8px 24px rgba(0,0,0,.06)}.exres .h1{font-size:22px;font-weight:700;margin:0 0 4px; text-align: center;}.exres .hint{color:var(--muted);font-weight:600;font-size:12px}.exres .sub{color:var(--sub)}.exres .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","DejaVu Sans Mono", monospace; font-variant-ligatures: none; letter-spacing:0; justify-content:center;}.exres .grid{display:grid; grid-template-columns:repeat(var(--cols), var(--cw));}.exres .row{height:var(--rowH); display:contents;}.exres .cell{display:flex; align-items:center; justify-content:center; height:var(--rowH); border-radius:3px;}.exres .cell > span{font-size:18px; line-height:1;}.exres .ans.match{ background:var(--okBg); outline:1px solid var(--okBr); }.exres .ans.error{ background:var(--errBg); outline:1px solid var(--errBr); }.exres .legend{display:flex;gap:18px;align-items:center;margin-top:12px}.exres .dot{width:16px;height:16px;border-radius:6px;outline:1px solid transparent}.exres .dot.ok{background:var(--okBg);outline-color:var(--okBr)}.exres .dot.err{background:var(--errBg);outline-color:var(--errBr)}.exres .stat h3{margin:0 0 8px;font-size:16px}.exres .row2{display:grid;grid-template-columns:repeat(3, 1fr); gap:18px}.exres .k{color:var(--muted);font-size:12px}.exres .v{font-size:18px;font-weight:800}.exres .stage{background:var(--chip); border-radius:12px; padding:6px 10px; display:inline-block; margin-left:auto}.exres .foot{margin:0 16px 28px;color:var(--muted);text-align:center}.rr{ --bg:#f6f8fb; --card:#fff; --ink:#0a1428; --muted:#8c94a3; --line:#e6e8f0; --ok:#16a34a; --ok-weak:#e8f8ef; --warn:#ef4444; --warn-weak:#fde8e8; --accent:#5b8cff; --accent-weak:#e9efff; font:14px/1.35 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--ink); }@media (prefers-color-scheme: dark){ .rr{ --bg:#0f1117; --card:#151821; --ink:#e5e7eb; --muted:#9aa3b2; --line:#262b39; --ok:#22c55e; --ok-weak:#062e1c; --warn:#fb7185; --warn-weak:#31161c; --accent:#7aa2ff; --accent-weak:#0f1a3a; }}.rr .wrap{ max-width:520px; margin:0 auto; min-height:100vh; background:var(--bg); padding: 14px 12px 28px; }.rr .card{ background:var(--card); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.06); padding:16px; }.rr .hdr{ font-weight:900; font-size:22px; letter-spacing:.2px; margin:2px 0 12px 2px; }.rr .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; }.rr .cell{ display:flex; flex-direction:column; align-items:center; padding:8px 0; }.rr .cell + .cell{ border-left:1px solid var(--line); }.rr .label{ font-size:13px; color:var(--muted); margin-bottom:6px; }.rr .value{ font-size:36px; font-weight:900; line-height:1; }.rr .sub{ font-weight:800; font-size:18px; color:var(--muted); margin-left:6px; }.rr .delta{ display:inline-flex; gap:6px; align-items:center; font-weight:800; padding:4px 10px; border-radius:10px; }.rr .delta.up{ background:var(--ok-weak); color:var(--ok); }.rr .delta.down{ background:var(--warn-weak); color:var(--warn); }.rr .delta.flat{ background:var(--accent-weak); color:var(--muted); }.rr .progress{ margin-top:16px; background:var(--card); border-radius:14px; box-shadow:0 6px 18px rgba(0,0,0,.06); padding:14px; }.rr .bar{ height:10px; background:#e9ecf2; border-radius:999px; position:relative; overflow:hidden; }.rr .fill{ position:absolute; left:0; top:0; height:100%; width:0%; background:var(--accent); border-radius:999px; transition:width .5s ease; }@media (prefers-color-scheme: dark){ .rr .bar{ background:#1f2430; } }.rr .bartext{ margin-top:8px; font-weight:800; color:var(--muted); }.rr .cta{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:16px; }.rr .btn{ width:100%; min-height:52px; border:0; border-radius:14px; font-weight:900; letter-spacing:.2px; cursor:pointer; background:#eef1f6; color:var(--ink);}@media (prefers-color-scheme: dark){ .rr .btn{ background:#1b2130; color:#e5e7eb; } }.rr .btn.primary{ background:#2563eb; color:#fff; }.rr .btn:disabled{ opacity:.5; cursor:default; }.rr .sp{ height:16px; }.home { --ink:#0a1428; --muted:#8c94a3; --line:#e6e8f0; --chip:#eef1f6; --accent:#2563eb; --card:#ffffff; --bg:#f6f8fb; font:14px/1.35 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color:var(--ink); }@media (prefers-color-scheme: dark){ .home { --ink:#e5e7eb; --muted:#9aa3b2; --line:#262b39; --chip:#1b2130; --accent:#3b82f6; --card:#151821; --bg:#0f1117; }}.home .wrap { max-width:560px; min-height:100vh; margin:0 auto; padding:12px; background:var(--bg); }.home .block { background:var(--card); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.06); padding:12px; }.home .grid4 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }.home .btn { min-height:44px; border:1px solid var(--line); border-radius:12px; background:var(--chip); color:var(--ink); font-weight:900; cursor:pointer; }.home .btn.primary { background:var(--accent); color:#fff; border-color:transparent; width: 100%; }.home .btn:disabled{ opacity:.5; cursor:default; }.home .round { display:flex; align-items:center; justify-content:space-between; padding:10px; border:1px solid var(--line); border-radius:16px; }.home .inc { display:flex; align-items:center; gap:10px; }.home .inc .icon { width:56px; height:40px; border-radius:12px; border:1px solid var(--line); background:transparent; color:var(--ink); font:900 20px/1.1 Inter, system-ui; }.home .hint { font-size:13px; color:var(--muted); }.home .value { font-size:20px; font-weight:900; min-width:3ch; text-align:center; }.home .sp { height:12px; }.home .footer { height:10vh; }
    /* ===== INLINE CSS END ===== */

    /* Фолбэк на случай отсутствия/ошибки CSS */
    :root { --bg:#0b0f14; --fg:#e5e7eb; }
    @media (prefers-color-scheme: light) { :root { --bg:#ffffff; --fg:#111111; } }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.5 system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    #app { min-height: 100dvh; max-width: 920px; margin: 0 auto; padding: 16px; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    noscript { display:block; margin: 12px 0; padding: 10px 12px; background:#fff3f3; color:#c00; border-left:4px solid #c00; }
  </style>
</head>
<body>
  <!-- Ссылка для скринридеров и клавиатуры -->
  <a class="sr-only" href="#root">Перейти к приложению</a>

  <div id="app">
    <noscript>Для работы этого офлайн-приложения нужен JavaScript.</noscript>
    <!-- Сюда монтируются экраны из app.js -->
    <main id="root" role="main" tabindex="-1"></main>
  </div>

  <!-- Inline JS (вставляется build.sh, порядок файлов задан в build.sh) -->
  <script>
    // ===== INLINE JS START =====

/* ===== BEGIN JS: src/js/core/utils.inline.js ===== */
/* utils.inline.js — общие утилиты для всех экранов (DOM, стили, хранилище,
   файлы, логгер, тосты) Экспортирует глобально window.util:
     - ensureBaseStyles()             — базовые UI-стили (кнопки/ряды/тосты),
   инжектируются один раз
     - injectStyle(id, css)           — одноразовый инжектор произвольного CSS
   по id
     - el(tag, className?, text?)     — быстрый создатель элементов
     - clear(el)                      — очистка детей
     - on(el, type, handler, opts?)   — навесить listener, вернуть функцию
   отписки
     - debounce(fn, ms)               — дебаунс
     - clamp(x,min,max)               — ограничение
     - fmt: { dateStamp(), pct(x), fmtPct(x), fmtAcc(x) }
     - local: { get, set, getJSON, setJSON, remove }
     - file:  { pickTextFile(), downloadText(filename, text) }
     - makeToaster(parent)            — { el, show(msg, isErr=false, ms=3000) }
     - log(ns)                        — namespaced-логгер
*/
(function() {
'use strict';

// ---------- style: base UI (one-time) ----------
let _baseInjected = false;
function ensureBaseStyles() {
  if (_baseInjected) return;
  _baseInjected = true;
  const css = `
.ui-wrap{ max-width: 880px; margin: 0 auto; padding: 16px 16px 28px; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
.ui-row{ display:flex; flex-wrap:wrap; gap: 14px; margin-top: 14px; }
.btn{
  appearance:none; border:0; cursor:pointer; user-select:none;
  padding: 12px 18px; border-radius: 12px; font-weight: 800; letter-spacing:.2px;
  background:#f2f4f8; color:#0a1428; box-shadow: 0 2px 0 rgba(10,20,40,.05) inset;
  transition: filter .15s ease, transform .02s ease;
}
.btn:active{ transform: translateY(1px); }
.btn.primary{ background:#22c55e; color:white; }
.btn.ghost{ background:transparent; outline: 1px solid rgba(10,20,40,.12); }
.note{ font-size:13px; opacity:.75; margin-top:6px; }
.hidden{ display:none !important; }

.toast{
  margin-top:10px; padding:10px 12px; border-radius:10px; font-weight:700; display:none;
  background:#e8f8ef; color:#0a1428;
}
.toast.err{ background:#fde8e8; color:#7f1d1d; }

@media (prefers-color-scheme: dark){
  .btn{ background:#1b2130; color:#e5e7eb; box-shadow: 0 2px 0 rgba(0,0,0,.25) inset; }
  .btn.ghost{ outline:1px solid rgba(255,255,255,.12); }
  .toast{ background:#052e1c; color:#d1fae5; }
  .toast.err{ background:#33151b; color:#fecaca; }
}
`;
  const st = document.createElement('style');
  st.id = 'util-base-ui';
  st.textContent = css;
  document.head.appendChild(st);
}

// ---------- generic style injector ----------
function injectStyle(id, css) {
  if (!id) throw new Error('injectStyle: id is required');
  if (document.getElementById(id)) return;
  const st = document.createElement('style');
  st.id = id;
  st.textContent = css;
  document.head.appendChild(st);
}

// ---------- dom helpers ----------
function el(tag, className, text) {
  const e = document.createElement(tag);
  if (className) e.className = className;
  if (text != null) e.textContent = text;
  return e;
}
function clear(node) {
  while (node && node.firstChild) node.removeChild(node.firstChild);
}
function on(node, type, handler, opts) {
  node.addEventListener(type, handler, opts);
  return () => node.removeEventListener(type, handler, opts);
}

// ---------- common small utils ----------
const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
function debounce(fn, ms) {
  let t = null;
  return function(...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), ms);
  };
}

// ---------- formatting ----------
const fmt = {
  dateStamp() {
    const d = new Date();
    const p = n => String(n).padStart(2, '0');
    return `${d.getFullYear()}-${p(d.getMonth() + 1)}-${p(d.getDate())}_${
        p(d.getHours())}-${p(d.getMinutes())}`;
  },
  pct(x) {
    x = +x || 0;
    if (x < 0) x = 0;
    if (x > 1) x = 1;
    return Math.round(x * 100);
  },
  fmtPct(x) {
    return `${fmt.pct(x)}%`;
  },
  fmtAcc(x) {
    x = +x || 0;
    if (x < 0) x = 0;
    if (x > 1) x = 1;
    return (Math.round(x * 100) / 100).toFixed(2);
  }
};

// ---------- localStorage wrappers ----------
const local = {
  get(key, def) {
    try {
      const v = localStorage.getItem(key);
      return v == null ? def : v;
    } catch (_) {
      return def;
    }
  },
  set(key, val) {
    try {
      localStorage.setItem(key, String(val));
    } catch (_) {
    }
  },
  getJSON(key, def) {
    try {
      const v = localStorage.getItem(key);
      return v == null ? def : JSON.parse(v);
    } catch (_) {
      return def;
    }
  },
  setJSON(key, val) {
    try {
      localStorage.setItem(key, JSON.stringify(val));
    } catch (_) {
    }
  },
  remove(key) {
    try {
      localStorage.removeItem(key);
    } catch (_) {
    }
  }
};

// ---------- file helpers ----------
const file = {
  async pickTextFile() {
    return new Promise((resolve) => {
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = 'text/plain,.txt';
      inp.onchange = async () => {
        const f = inp.files && inp.files[0];
        if (!f) return resolve(null);
        const txt = await f.text();
        resolve({name: f.name, text: txt});
      };
      inp.click();
    });
  },
  downloadText(filename, text) {
    const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || `download_${fmt.dateStamp()}.txt`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2500);
  }
};

// ---------- toaster ----------
function makeToaster(parent) {
  const elToast = el('div', 'toast');
  parent.appendChild(elToast);
  function show(msg, isErr = false, ms = 3000) {
    elToast.textContent = String(msg == null ? '' : msg);
    elToast.classList.toggle('err', !!isErr);
    elToast.style.display = 'block';
    clearTimeout(show._t);
    show._t = setTimeout(() => {
      elToast.style.display = 'none';
    }, Math.max(0, ms | 0));
  }
  return {el: elToast, show};
}

// ---------- logger ----------
function log(ns) {
  const p = ns ? `[${ns}]` : '';
  return (...a) => console.log(p, ...a);
}

// ---------- export ----------
const api = {
  ensureBaseStyles,
  injectStyle,
  el,
  clear,
  on,
  debounce,
  clamp,
  fmt,
  local,
  file,
  makeToaster,
  log
};
if (typeof window !== 'undefined')
  window.util = api;
else if (typeof globalThis !== 'undefined')
  globalThis.util = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/core/lexidb.inline.js ===== */
/* lexidb.inline.js — offline словарь + статы (IndexedDB) для немецких
   существительных Экспортирует глобально: window.lexidb = {
       // DB
       open, // Promise<void>
       // Terms
       importText, getTerm, putTerm, allTerms, listTermIds,
       // Stats V2
       getStats, ensureStats, putStats, coverage, newTermIds,
       // Helpers
       applyPlural, pluralOf,
       // meta
       version: '2.0.0-final'
     }
*/
(function() {
'use strict';

const DB_NAME = 'lexi.v2';
const DB_VERSION = 1;
const STORE_TERMS = 'terms';
const STORE_STATS = 'stats';

const ALLOWED_ART = new Set(['der', 'die', 'das']);
const ALLOWED_PL = new Set([
  '-', '"-', '"-e', '"-en', '-e', '-en', '"-n', '-n', '-nen', '-s', '-er',
  '"-er'
]);

// Инициализационные значения для стейтов режимов
const INIT_S = {
  M: 0.75,
  C: 0.60,
  P: 0.50
};  // days
const INIT_Q = 0.5;
const INIT_STREAK = 0;

// --- IndexedDB utils ---
let _dbPromise = null;
function open() {
  if (_dbPromise) return _dbPromise;
  _dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE_TERMS)) {
        const os = db.createObjectStore(STORE_TERMS, {keyPath: 'id'});
        os.createIndex('art', 'art', {unique: false});
        os.createIndex('de', 'de', {unique: false});
        os.createIndex('pl', 'pl', {unique: false});
      }
      if (!db.objectStoreNames.contains(STORE_STATS)) {
        const os = db.createObjectStore(STORE_STATS, {keyPath: 'id'});
        os.createIndex('intro', 'intro', {unique: false});
        os.createIndex('stage', 'stage', {unique: false});
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return _dbPromise;
}

function withStores(mode, names, fn) {
  return open().then(db => new Promise((resolve, reject) => {
                       const tx = db.transaction(names, mode);
                       const stores = names.map(n => tx.objectStore(n));
                       let done = false;
                       tx.oncomplete = () => {
                         if (!done) {
                           done = true;
                           resolve();
                         }
                       };
                       tx.onabort = tx.onerror = () => {
                         if (!done) {
                           done = true;
                           reject(tx.error);
                         }
                       };
                       Promise.resolve(fn.apply(null, stores))
                           .then(val => { /* pass; tx completes */
                                          resolve(val);
                           })
                           .catch(err => {
                             try {
                               tx.abort();
                             } catch (_) {
                             }
                             reject(err);
                           });
                     }));
}

function reqAsPromise(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getAll(store) {
  if ('getAll' in store) return await reqAsPromise(store.getAll());
  // fallback cursor
  const out = [];
  await new Promise((resolve, reject) => {
    const req = store.openCursor();
    req.onsuccess = (e) => {
      const cur = e.target.result;
      if (!cur) return resolve();
      out.push(cur.value);
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  return out;
}

async function getAllKeys(store) {
  if ('getAllKeys' in store) return await reqAsPromise(store.getAllKeys());
  const out = [];
  await new Promise((resolve, reject) => {
    const req = store.openKeyCursor();
    req.onsuccess = (e) => {
      const cur = e.target.result;
      if (!cur) return resolve();
      out.push(cur.primaryKey);
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  return out;
}

// --- Helpers: strings / arrays ---
function normSpaces(s) {
  return String(s || '').replace(/\s+/g, ' ').trim();
}
function uniq(arr) {
  const seen = new Set();
  const out = [];
  for (const x of arr) {
    const k = typeof x === 'string' ? x.trim() : x;
    if (!k && k !== 0) continue;
    if (!seen.has(k)) {
      seen.add(k);
      out.push(k);
    }
  }
  return out;
}

// --- ID builder & validators ---
function makeId(art, de, pl) {
  art = String(art || '').toLowerCase().trim();
  de = normSpaces(de);
  pl = (pl == null || pl === '') ? '-' : String(pl).trim();
  return `${art} ${de} ${pl}`;
}

function validateArt(art) {
  art = String(art || '').toLowerCase().trim();
  if (!ALLOWED_ART.has(art)) throw new Error(`Недопустимый артикль: "${art}"`);
  return art;
}

function validatePl(pl) {
  pl = (pl == null || pl === '') ? '-' : String(pl).trim();
  if (!ALLOWED_PL.has(pl))
    throw new Error(`Недопустимый шаблон мн. числа: "${pl}"`);
  return pl;
}

// --- Plural building ---
function applyUmlautOnce(stem) {
  // Эвристика: сначала 'au' -> 'äu' (последнее вхождение), иначе последний
  // a/o/u Учитываем регистр для первой буквы Пример: Hand -> Hände; Haus ->
  // Häuser; Mutter -> Mütter; Sohn -> Söhne
  const map = {'a': 'ä', 'o': 'ö', 'u': 'ü'};
  // Try 'au' or 'Au' (последнее вхождение)
  let idx = stem.toLowerCase().lastIndexOf('au');
  if (idx >= 0) {
    const seg = stem.slice(idx, idx + 2);
    const repl = (seg[0] === seg[0].toUpperCase()) ? 'Äu' : 'äu';
    return stem.slice(0, idx) + repl + stem.slice(idx + 2);
  }
  // Else last single vowel a/o/u
  let best = -1, vch = '';
  for (const v of ['a', 'o', 'u']) {
    const pos = stem.toLowerCase().lastIndexOf(v);
    if (pos > best) {
      best = pos;
      vch = v;
    }
  }
  if (best >= 0) {
    const orig = stem[best];
    const lower = orig.toLowerCase();
    const target = map[lower];
    const repl = (orig === orig.toUpperCase()) ? target.toUpperCase() : target;
    return stem.slice(0, best) + repl + stem.slice(best + 1);
  }
  return stem;  // нет подходящей гласной
}

function applyPlural(base, pattern) {
  base = String(base || '').trim();
  pattern = validatePl(pattern);
  const needUmlaut = pattern.startsWith('"');
  const suffix = pattern === '-' ? '' : pattern.replace(/^"?-?/, '');
  const stem = needUmlaut ? applyUmlautOnce(base) : base;
  return stem + suffix;
}

function pluralOf(art, de, pl) {
  return applyPlural(de, validatePl(pl));
}

// --- Parsing import blocks ---
function parseTermLine(line) {
  // ожидаем: "<art> <de> <pl>"
  // где <pl> ∈ ALLOWED_PL; выделяем последний токен как pl
  line = normSpaces(line);
  const parts = line.split(' ');
  if (parts.length < 2) throw new Error('Слишком короткая term-строка');
  const art = validateArt(parts[0]);
  const maybePl = parts[parts.length - 1];
  let pl = null, de = null;
  if (ALLOWED_PL.has(maybePl)) {
    pl = maybePl;
    de = normSpaces(parts.slice(1, -1).join(' '));
  } else {
    throw new Error(
        `Не найден корректный шаблон мн. числа в конце строки: "${line}"`);
  }
  if (!de) throw new Error('Пустое слово (de) после парсинга');
  return {art, de, pl};
}

function parseRuLine(line) {
  // "рука; кисть (руки);" -> ['рука','кисть (руки)']
  const raw = String(line || '').trim().replace(/;+\s*$/, '');
  if (!raw) return [];
  return uniq(raw.split(';').map(s => s.trim()).filter(Boolean));
}

function mergeRu(existingRu, incomingRu) {
  const a = Array.isArray(existingRu) ? existingRu : [];
  const b = Array.isArray(incomingRu) ? incomingRu : [];
  // Сохраняем порядок: сначала новые (b), затем недостающие из a
  const out = [];
  const seen = new Set();
  for (const x of b) {
    const t = x.trim();
    if (t && !seen.has(t)) {
      seen.add(t);
      out.push(t);
    }
  }
  for (const x of a) {
    const t = x.trim();
    if (t && !seen.has(t)) {
      seen.add(t);
      out.push(t);
    }
  }
  return out;
}

// --- Default stats factory ---
function nowTs() {
  return Date.now();
}
function defaultModeState(Sdays, now) {
  return {
    S: +Sdays,           // days
    last: now,           // ms
    due: now,            // ms
    q: INIT_Q,           // 0..1
    streak: INIT_STREAK  // int
  };
}
function defaultStats(id, now) {
  return {
    id,
    stage: 'MC5',
    intro: false,
    M: defaultModeState(INIT_S.M, now),
    C: defaultModeState(INIT_S.C, now),
    P: defaultModeState(INIT_S.P, now)
  };
}

// --- Public: Terms CRUD ---
async function getTerm(id) {
  return await withStores('readonly', [STORE_TERMS], async (terms) => {
    return await reqAsPromise(terms.get(id));
  });
}

async function putTerm(term) {
  // expects {id, art, de, pl, ru[]}
  if (!term || !term.id) throw new Error('putTerm: отсутствует id');
  return await withStores('readwrite', [STORE_TERMS], async (terms) => {
    return await reqAsPromise(terms.put(term));
  });
}

async function listTermIds() {
  return await withStores('readonly', [STORE_TERMS], async (terms) => {
    return await getAllKeys(terms);
  });
}

async function allTerms() {
  return await withStores('readonly', [STORE_TERMS], async (terms) => {
    return await getAll(terms);
  });
}

// --- Public: Stats V2 CRUD ---
async function getStats(id) {
  return await withStores('readonly', [STORE_STATS], async (stats) => {
    return await reqAsPromise(stats.get(id));
  });
}

async function putStats(statsObj) {
  if (!statsObj || !statsObj.id) throw new Error('putStats: отсутствует id');
  return await withStores('readwrite', [STORE_STATS], async (stats) => {
    return await reqAsPromise(stats.put(statsObj));
  });
}

async function ensureStats(id) {
  return await withStores('readwrite', [STORE_STATS], async (stats) => {
    const cur = await reqAsPromise(stats.get(id));
    if (cur) return cur;
    const s = defaultStats(id, nowTs());
    await reqAsPromise(stats.put(s));
    return s;
  });
}

async function coverage() {
  // % слов, введённых в обучение (intro==true) / общее число terms
  const [tot, introduced] = await withStores(
      'readonly', [STORE_TERMS, STORE_STATS], async (terms, stats) => {
        const [allIds, allStats] =
            await Promise.all([getAllKeys(terms), getAll(stats)]);
        const introCount =
            allStats.reduce((acc, s) => acc + (s && s.intro ? 1 : 0), 0);
        return [allIds.length, introCount];
      });
  if (tot === 0) return 0;
  return introduced / tot;
}

async function newTermIds() {
  // те, кто ещё не intro==true (либо нет stats)
  return await withStores(
      'readonly', [STORE_TERMS, STORE_STATS], async (terms, stats) => {
        const [ids, statList] =
            await Promise.all([getAllKeys(terms), getAll(stats)]);
        const stById = new Map(statList.map(s => [s.id, s]));
        const out = [];
        for (const id of ids) {
          const st = stById.get(id);
          if (!st || !st.intro) out.push(id);
        }
        return out;
      });
}

// --- Public: Import ---
async function importText(txt) {
  // Формат: блоки через пустую строку: line1=term, line2=ru
  // Возвращает { added, updated, skipped, errors: [ {blockIndex, message} ] }
  const blocks =
      String(txt || '').split(/\r?\n\r?\n+/).map(b => b.trim()).filter(Boolean);
  const res = {added: 0, updated: 0, skipped: 0, errors: []};

  await withStores(
      'readwrite', [STORE_TERMS, STORE_STATS], async (terms, stats) => {
        for (let i = 0; i < blocks.length; i++) {
          const block = blocks[i];
          const lines = block.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          if (lines.length < 1) {
            res.skipped++;
            continue;
          }
          const termLine = lines[0];
          const ruLine = lines[1] || '';
          try {
            const {art, de, pl} = parseTermLine(termLine);
            const ru = parseRuLine(ruLine);
            const id = makeId(art, de, pl);
            const existing = await reqAsPromise(terms.get(id));
            if (existing) {
              // merge ru, update only if changed
              const mergedRu = mergeRu(existing.ru || [], ru);
              const needUpdate = JSON.stringify(mergedRu) !==
                  JSON.stringify(existing.ru || []);
              if (needUpdate) {
                existing.ru = mergedRu;
                await reqAsPromise(terms.put(existing));
                res.updated++;
              } else {
                res.skipped++;
              }
            } else {
              const record = {id, art, de, pl, ru};
              await reqAsPromise(terms.put(record));
              // create default stats if not present
              const st = await reqAsPromise(stats.get(id));
              if (!st) {
                await reqAsPromise(stats.put(defaultStats(id, nowTs())));
              }
              res.added++;
            }
          } catch (err) {
            res.errors.push(
                {blockIndex: i, message: String(err && err.message || err)});
          }
        }
      });

  return res;
}

// --- Public API export ---
const api = {
  open,
  importText,

  getTerm,
  putTerm,
  allTerms,
  listTermIds,

  getStats,
  ensureStats,
  putStats,
  coverage,
  newTermIds,

  applyPlural,
  pluralOf,

  version: '2.0.0-final'
};

// attach
if (typeof window !== 'undefined')
  window.lexidb = api;
else if (typeof globalThis !== 'undefined')
  globalThis.lexidb = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/core/lexiparts.inline.js ===== */
/* lexiparts.inline.js — генерация чанков/букв и опций клавиатуры для режимов
   CHUNKS/COMPOSE Использует (по желанию) window.lexidb для построения
   глобального инвентаря. Экспортирует глобально: window.lexiparts = {
       // Разбиение
       splitChunks(word),     // -> string[] (чанки 1..3)
       splitCompose(word),    // -> string[] (по буквам с учётом äöüß)
       // Инвентарь (ленивое построение из lexidb)
       ensureInventory(),     // -> Promise<{lettersFreq, chunksFreq, letters,
   chunks}> clearInventoryCache(),
       // Опции для шагов
       chunkOptionsFor(word, index, k=5),   // -> Promise<string[]> (варианты
   для очередного чанка) letterOptionsFor(word, index, k=6),  // ->
   Promise<string[]> (варианты для очередной буквы)
       // Планировщики шагов (все шаги сразу)
       planChunks(word, k=5),   // -> Promise<string[][]>   (по шагам)
       planCompose(word, k=6),  // -> Promise<string[][]>   (по шагам)
       // RNG
       setSeed(seedNumber),
       // Служебное
       version: '2.0.0-final'
     }
*/
(function() {
'use strict';

// ---------------- RNG: детерминируемый и быстрый ----------------
let _rngState =
    (typeof performance !== 'undefined' ? performance.now() : Date.now()) >>> 0;
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
let _rand = mulberry32(_rngState);
function setSeed(seed) {
  _rngState = (seed >>> 0);
  _rand = mulberry32(_rngState);
}
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(_rand() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function weightedSampleDistinct(items, weightFn, k, excludeSet) {
  const pool = [];
  for (const it of items) {
    if (excludeSet && excludeSet.has(it)) continue;
    const w = Math.max(0, +weightFn(it) || 0);
    if (w <= 0) continue;
    pool.push([it, w]);
  }
  if (pool.length <= k) return pool.map(p => p[0]);
  // Roulette-wheel without replacement
  const res = [];
  const tmp = pool.slice();
  for (let n = 0; n < k && tmp.length > 0; n++) {
    const total = tmp.reduce((s, p) => s + p[1], 0);
    let r = _rand() * total, pick = 0;
    for (let i = 0; i < tmp.length; i++) {
      r -= tmp[i][1];
      if (r <= 0) {
        pick = i;
        break;
      }
    }
    res.push(tmp[pick][0]);
    tmp.splice(pick, 1);
  }
  return res;
}

// ---------------- Базовые наборы и утилиты ----------------
const VOWELS = 'aeiouyäöü';
const GERMAN_LOWER = Array.from('abcdefghijklmnopqrstuvwxyzäöüß');
function isVowel(ch) {
  return VOWELS.includes(ch.toLowerCase());
}

// Список приоритетных графем для ЧАНКОВ (макс длина 3, чтобы соответствовать
// ТЗ) Порядок важен — более длинные сначала
const CHUNK_GRAPHEMES = [
  // триграфы
  'sch', 'chs', 'spr', 'str', 'spl',
  // диграфы — частые
  'ch', 'ck', 'tz', 'pf', 'ph', 'qu', 'ng', 'sp', 'st', 'ei', 'ie', 'au', 'eu',
  'äu',
  // удвоенные согласные (диграфы)
  'ss', 'll', 'mm', 'nn', 'rr', 'tt', 'pp', 'ff', 'kk', 'dd', 'bb', 'gg', 'zz'
];

// Набор замен/пары для правдоподобных дистракторов
const CONFUSION_PAIRS = [
  ['ie', 'ei'], ['eu', 'äu'], ['ch', 'sch'], ['ck', 'k'], ['tz', 'z'],
  ['sp', 'st'], ['pf', 'f'], ['ph', 'f'], ['qu', 'ku'], ['ä', 'a'], ['ö', 'o'],
  ['ü', 'u'], ['ß', 'ss']
];

const UPPER_MAP = {
  'ä': 'Ä',
  'ö': 'Ö',
  'ü': 'Ü',
  'ß': 'ẞ'
};  // визуальная корректность

function lower(s) {
  return String(s || '').toLowerCase();
}
function keepCase(sample, pattern) {
  // Если pattern начинается с заглавной — делаем первую букву sample заглавной
  if (!pattern) return sample;
  if (pattern[0] === pattern[0].toUpperCase()) {
    if (sample.length === 0) return sample;
    const first = sample[0];
    const up = UPPER_MAP[first] || first.toUpperCase();
    return up + sample.slice(1);
  }
  return sample;
}

// ---------------- Разбиение слова ----------------
function splitChunks(word) {
  // Возвращает массив чанков 1..3 символа. Сохраняет регистр оригинала.
  const w = String(word || '');
  const lw = w.toLowerCase();
  const out = [];
  for (let i = 0; i < lw.length;) {
    let matched = null;
    // пробуем триграфы/диграфы
    for (const g of CHUNK_GRAPHEMES) {
      const L = g.length;
      if (i + L <= lw.length && lw.slice(i, i + L) === g) {
        matched = w.slice(i, i + L);  // оригинал с регистром
        i += L;
        break;
      }
    }
    if (!matched) {
      // одиночная буква
      matched = w[i];
      i += 1;
    }
    out.push(matched);
  }
  return out;
}

function splitCompose(word) {
  // По буквам (включая äöüß как единицы)
  const w = String(word || '');
  return Array.from(w);
}

function confusionsOf(tokenLower) {
  const out = new Set();
  for (const [a, b] of CONFUSION_PAIRS) {
    if (tokenLower === a) out.add(b);
    if (tokenLower === b) out.add(a);
  }
  // мягкая мутация (даже для многобуквенных чанков)
  out.add(mutateOnce(tokenLower));
  return Array.from(out).filter(x => x && x !== tokenLower);
}

// ---------------- Инвентарь (частоты) ----------------
let _inventory = null;  // {lettersFreq, chunksFreq, letters, chunks}

async function ensureInventory() {
  if (_inventory) return _inventory;
  const inv =
      {lettersFreq: new Map(), chunksFreq: new Map(), letters: [], chunks: []};
  const addFreq = (map, key, inc = 1) =>
      map.set(key, (map.get(key) || 0) + inc);

  let terms = [];
  try {
    if (typeof window !== 'undefined' && window.lexidb &&
        window.lexidb.allTerms) {
      await window.lexidb.open?.();
      terms = await window.lexidb.allTerms();
    }
  } catch (_) {
  }

  if (!terms || !terms.length) {
    for (const ch of GERMAN_LOWER) {
      addFreq(inv.lettersFreq, ch, 1);
    }
    for (const g of CHUNK_GRAPHEMES) {
      addFreq(inv.chunksFreq, g, 1);
    }
  } else {
    for (const t of terms) {
      const de = String(t.de || '');
      for (const L of splitCompose(de).map(lower))
        addFreq(inv.lettersFreq, L, 1);
      for (const C of splitChunks(de).map(lower)) addFreq(inv.chunksFreq, C, 1);
    }
    // маленький «подсев» базового алфавита/графем — по 1 очку
    for (const ch of GERMAN_LOWER) addFreq(inv.lettersFreq, ch, 1);
    for (const g of CHUNK_GRAPHEMES) addFreq(inv.chunksFreq, g, 1);
  }

  inv.letters = Array.from(inv.lettersFreq.keys());
  inv.chunks = Array.from(inv.chunksFreq.keys());
  _inventory = inv;
  return inv;
}

function clearInventoryCache() {
  _inventory = null;
}

// ---------------- Генерация дистракторов ----------------
function mutateOnce(token) {
  const x = lower(token);
  // Пробуем пары путаниц
  for (const [a, b] of CONFUSION_PAIRS) {
    if (x === a) return b;
    if (x === b) return a;
  }
  // Лёгкая буква-замена: поменять одну букву на соседнюю по набору
  if (x.length >= 1) {
    const i = Math.floor(_rand() * x.length);
    const c = x[i];
    const alphabet = GERMAN_LOWER;
    const alt = alphabet[Math.floor(_rand() * alphabet.length)];
    return x.slice(0, i) + alt + x.slice(i + 1);
  }
  return x;
}

function sameLength(items, len) {
  return items.filter(s => s.length === len);
}
function sameType(items, token) {
  // грубая эвристика: по шаблону "V/C" (гласная/согласная)
  const pat =
      Array.from(lower(token)).map(c => isVowel(c) ? 'V' : 'C').join('');
  return items.filter(
      s => Array.from(lower(s)).map(c => isVowel(c) ? 'V' : 'C').join('') ===
          pat);
}

// ---------------- Опции для CHUNKS ----------------
// CHUNKS: если целевой чанк = 1 символ, то все варианты тоже односимвольные
async function chunkOptionsFor(word, index, _ignoredK) {
  const inv = await ensureInventory();
  const chunks = splitChunks(word);
  const target = chunks[index] || '';
  const tLower = lower(target);
  const isSingle = tLower.length === 1;

  // исключаем ВСЕ чанки из того же слова, чтобы не подсказывать порядок
  const excl = new Set(chunks.map(lower));
  excl.add(tLower);

  const freq = (s) => inv.chunksFreq.get(lower(s)) || 1;

  // базовый пул: либо все односимвольные, либо 1..3 символа
  const basePoolAll = inv.chunks;
  const basePool = isSingle ?
      basePoolAll.filter(s => s.length === 1) :
      basePoolAll.filter(s => s.length >= 1 && s.length <= 3);

  const wantSimilar = _rand() < 0.5;
  const picks = [];

  // «похожие» (до 2 шт.), с учётом ограничения по длине
  if (wantSimilar) {
    const sims = confusionsOf(tLower)
                     .filter(s => !excl.has(s))
                     .filter(
                         s => isSingle ? s.length === 1 :
                                         (s.length >= 1 && s.length <= 3));
    for (const s of shuffle(sims).slice(0, 2)) {
      picks.push(keepCase(s, target));
      excl.add(lower(s));
    }
  }
  // добираем по частоте из пула, избегая исключений
  const need = Math.max(0, 4 - picks.length);
  const more = weightedSampleDistinct(basePool, (s) => freq(s), need, excl)
                   .map(s => keepCase(s, target));
  picks.push(...more);

  // крайний случай: домутируем до 4 дистракторов
  while (picks.length < 4) {
    let m = mutateOnce(tLower);
    if (isSingle) m = m.slice(0, 1);  // гарантируем 1 символ

    const okLen =
        isSingle ? (m.length === 1) : (m.length >= 1 && m.length <= 3);
    if (m && okLen && !excl.has(m)) {
      picks.push(keepCase(m, target));
      excl.add(m);
      continue;
    }
    // резервная ветка, если мутация не подошла
    if (isSingle) {
      const ch = GERMAN_LOWER[Math.floor(_rand() * GERMAN_LOWER.length)];
      if (!excl.has(ch)) {
        picks.push(keepCase(ch, target));
        excl.add(ch);
      }
    } else {
      const fb = basePool[Math.floor(_rand() * basePool.length)];
      if (fb && !excl.has(lower(fb))) {
        picks.push(keepCase(fb, target));
        excl.add(lower(fb));
      }
    }
  }

  return shuffle([target, ...picks.slice(0, 4)]);
}

// ---------------- Опции для COMPOSE ----------------
async function letterOptionsFor(word, index, _ignoredK) {
  const inv = await ensureInventory();
  const letters = splitCompose(word);
  const target = letters[index] || '';
  const tLower = lower(target);

  // исключаем ВСЕ буквы этого слова, кроме целевой
  const excl = new Set(letters.map(lower));
  excl.delete(tLower);
  excl.add(tLower);

  const freq = (s) => inv.lettersFreq.get(lower(s)) || 1;
  const basePool =
      (inv.letters && inv.letters.length >= 12) ? inv.letters : GERMAN_LOWER;

  const wantSimilar = _rand() < 0.5;
  const picks = [];

  if (wantSimilar) {
    const sims =
        confusionsOf(tLower).filter(s => s.length === 1 && !excl.has(s));
    for (const s of shuffle(sims).slice(0, 2)) {
      picks.push(keepCase(s, target));
      excl.add(lower(s));
    }
  }

  // добираем случайными буквами
  const need = Math.max(0, 4 - picks.length);
  const more = weightedSampleDistinct(basePool, (s) => freq(s), need, excl)
                   .map(s => keepCase(s, target));
  picks.push(...more);

  while (picks.length < 4) {
    const m = mutateOnce(tLower);
    if (m && m[0] && !excl.has(m[0])) {
      picks.push(keepCase(m[0], target));
      excl.add(m[0]);
    }
  }

  return shuffle([target, ...picks.slice(0, 4)]);
}


// ---------------- Планировщики шагов ----------------
async function planChunks(word, _k) {
  const chunks = splitChunks(word);
  const steps = [];
  for (let i = 0; i < chunks.length; i++) {
    // eslint-disable-next-line no-await-in-loop
    const opts = await chunkOptionsFor(word, i, 5);
    steps.push(opts);
  }
  return steps;
}
async function planCompose(word, _k) {
  const letters = splitCompose(word);
  const steps = [];
  for (let i = 0; i < letters.length; i++) {
    // eslint-disable-next-line no-await-in-loop
    const opts = await letterOptionsFor(word, i, 5);
    steps.push(opts);
  }
  return steps;
}

// ---------------- Экспорт API ----------------
const api = {
  // Разбиение
  splitChunks,
  splitCompose,
  // Инвентарь
  ensureInventory,
  clearInventoryCache,
  // Опции
  chunkOptionsFor,
  letterOptionsFor,
  // Шаги
  planChunks,
  planCompose,
  // RNG
  setSeed,
  // Версия
  version: '2.0.0-final'
};

if (typeof window !== 'undefined')
  window.lexiparts = api;
else if (typeof globalThis !== 'undefined')
  globalThis.lexiparts = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/core/cardengine.inline.js ===== */
/* cardengine.inline.js — выбор следующей карточки и обновление статов
   Зависимости (опционально, но ожидаемо): window.lexidb (из lexidb.inline.js)
   Экспортирует глобально:
     window.cardengine = {
       configure,              // (settings?: Partial<Settings>) -> void
       sampleNext,             // (now=Date.now()) -> Promise<{termId, mode}>
       onReview,               // (termId, mode, result:boolean, now=Date.now())
   -> Promise<void> getProgress,            // () -> Promise<{coverage, debt,
   nearly, totalIntro, totalTerms}>
       // вспомогательное
       getStatsSafe,           // (termId) -> Promise<TermStatsV2>
       introduce,              // (termId, now=Date.now()) -> Promise<void>
       version: '2.0.0-final'
     }

   Минимальные структуры (как в ТЗ) + счётчик n (число предъявлений в режиме):
     ModeState = { S:number, last:number, due:number, q:number, streak:number,
   n?:number } TermStatsV2 = { id, stage:'MC5'|'CHUNKS'|'COMPOSE',
   intro:boolean, M:ModeState, C:ModeState, P:ModeState }

   Настройки (интерфейс из ТЗ):
     Settings = {
       id:'singleton',
       leitnerDays:number[],                // напр. [0,1,3,7,15,30,60]
       toCHUNKS:{ minBox:number,minShown:number,minAcc:number },
       toCOMPOSE:{minBox:number,minShown:number,minAcc:number },
       maxIntervalDays:number,              // напр. 60
       targetNewShare:number                // 0..1
     }
*/
(function() {
'use strict';

// ---- Константы «ядра памяти» (по умолчанию из ТЗ) ----
const TAU = 0.9;     // целевая надёжность показа
const DELTA = 0.05;  // коридор «почти due»
const LAMBDA = 0.2;  // штраф за уверенную ошибку
const RHO = 0.2;     // EWMA-коэффициент точности q
const ETA = {
  MC5: 0.30,
  CHUNKS: 0.36,
  COMPOSE: 0.45
};  // шаги обучения
const S_MIN = 0.25;   // дни
const ALPHA = 0.5;    // вес (1-q)
const BETA = 0.3;     // вес «долга»
const KAPPA = 6;      // «жадность» softmax
const Q_DOWN = 0.55;  // порог для понижения
const QUICK_RETRY_MS =
    2 * 60 * 1000;  // 2 минуты (внутрисессионный мягкий повтор)
const ONE_DAY = 86400000;

// ---- Настройки по умолчанию (можно переопределить через configure) ----
const defaultSettings = Object.freeze({
  id: 'singleton',
  leitnerDays: [0, 1, 3, 7, 15, 30, 60],
  toCHUNKS: {minBox: 3, minShown: 5, minAcc: 0.75},
  toCOMPOSE: {minBox: 2, minShown: 10, minAcc: 0.70},
  maxIntervalDays: 60,
  targetNewShare: 0.6
});

let settings = {...defaultSettings};

function configure(partial) {
  if (!partial) return;
  // неглубокий merge
  const s = {...settings, ...partial};
  if (partial.toCHUNKS)
    s.toCHUNKS = {...settings.toCHUNKS, ...partial.toCHUNKS};
  if (partial.toCOMPOSE)
    s.toCOMPOSE = {...settings.toCOMPOSE, ...partial.toCOMPOSE};
  if (Array.isArray(partial.leitnerDays))
    s.leitnerDays = partial.leitnerDays.slice();
  settings = s;
}

// ---- Вспомогательные функции математики ----
const LOG2_1_OVER_TAU = Math.log2(1 / TAU);

function clamp(v, a, b) {
  return Math.max(a, Math.min(b, v));
}
function expm1(x) {
  return Math.exp(x) - 1;
}

function pHat(dtDays, S) {  // 2^{-Δt/S}
  if (S <= 0) S = S_MIN;
  return Math.pow(2, -dtDays / S);
}

function dueFrom(now, S) {  // now + S * log2(1/τ)
  return now + S * ONE_DAY * LOG2_1_OVER_TAU;
}

function Smax() {  // из настроек maxIntervalDays
  return settings.maxIntervalDays / LOG2_1_OVER_TAU;
}

function clipExp(logS, sMin, sMax) {  // exp(clamp(logS))
  const v = Math.exp(clamp(logS, Math.log(sMin), Math.log(sMax)));
  return v;
}

function intervalDaysFromS(S) {
  return S * LOG2_1_OVER_TAU;
}

function currentLeitnerBox(S) {
  // «Виртуальный» бокс = индекс наибольшего интервала в settings.leitnerDays,
  // который <= текущего интервала
  const d = intervalDaysFromS(S);
  const L = settings.leitnerDays;
  let box = 0;
  for (let i = 0; i < L.length; i++) {
    if (d >= L[i])
      box = i;
    else
      break;
  }
  return box;
}

function softmaxSample(weights) {
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < weights.length; i++) {
    r -= weights[i];
    if (r <= 0) return i;
  }
  return weights.length - 1;
}

// ---- Быстрые внутрисессионные повторы (RAM only) ----
// элементы: { id, mode, availableAt }
const quickQueue = [];
function enqueueQuickRetry(id, mode, now) {
  quickQueue.push({id, mode, availableAt: now + QUICK_RETRY_MS});
}
function pickupQuickRetry(now) {
  for (let i = 0; i < quickQueue.length; i++) {
    if (quickQueue[i].availableAt <= now) {
      const it = quickQueue.splice(i, 1)[0];
      return it;
    }
  }
  return null;
}

// ---- Доступ к базе (lexidb) ----
async function getStatsSafe(termId) {
  await window.lexidb.open?.();
  const s = await window.lexidb.getStats(termId);
  if (s) return normalizeStats(s);
  // если нет — создадим дефолт (lexidb.ensureStats уже это делает)
  return await window.lexidb.ensureStats(termId).then(normalizeStats);
}

function normalizeModeState(ms) {
  // добавляем n при отсутствии
  if (typeof ms.n !== 'number') ms.n = 0;
  return ms;
}

function normalizeStats(s) {
  s.M = normalizeModeState(s.M);
  s.C = normalizeModeState(s.C);
  s.P = normalizeModeState(s.P);
  // корректность due при странных S
  if (!(s.M.S > 0)) s.M.S = S_MIN;
  if (!(s.C.S > 0)) s.C.S = S_MIN;
  if (!(s.P.S > 0)) s.P.S = S_MIN;
  if (!(s.M.due > 0)) s.M.due = dueFrom(Date.now(), s.M.S);
  if (!(s.C.due > 0)) s.C.due = dueFrom(Date.now(), s.C.S);
  if (!(s.P.due > 0)) s.P.due = dueFrom(Date.now(), s.P.S);
  return s;
}

// ---- Сервис: introduce нового терма ----
async function introduce(termId, now) {
  const s = await getStatsSafe(termId);
  s.intro = true;
  s.stage = 'MC5';
  // «вводим» с немедленным показом
  s.M.last = now;
  s.M.due = now;
  await window.lexidb.putStats(s);
}

// ---- Кандидаты и приоритеты ----
async function collectCandidates(now) {
  const ids = await window.lexidb.listTermIds();
  const stats = await Promise.all(ids.map(id => window.lexidb.getStats(id)));
  const introStats = [];
  let totalIntro = 0;
  for (let i = 0; i < ids.length; i++) {
    const st = stats[i] ? normalizeStats(stats[i]) : null;
    if (!st) {
      continue;
    }
    if (st.intro) totalIntro++;
    introStats.push(st);
  }

  const due = [];
  const nearly = [];
  for (const st of introStats) {
    if (!st.intro) continue;
    const mode = st.stage || 'MC5';
    const mstate = (mode === 'MC5' ? st.M : mode === 'CHUNKS' ? st.C : st.P);
    const dtDays = (now - mstate.last) / ONE_DAY;
    const p = pHat(Math.max(1 / 1440, dtDays), mstate.S);
    if (mstate.due <= now)
      due.push(st);
    else if (p > TAU && p <= TAU + DELTA)
      nearly.push(st);
  }
  return {
    due,
    nearly,
    totalIntro,
    totalTerms: ids.length,
    allIntroStats: introStats
  };
}

function priorityOf(st, now) {
  const mode = st.stage || 'MC5';
  const ms = (mode === 'MC5' ? st.M : mode === 'CHUNKS' ? st.C : st.P);
  const dtDays = Math.max(1 / 1440, (now - ms.last) / ONE_DAY);
  const p = pHat(dtDays, ms.S);
  const overdueRatio =
      Math.max(0, (now - ms.due) / (ms.S * ONE_DAY * LOG2_1_OVER_TAU));
  const pi = Math.max(0, TAU - p) + ALPHA * (1 - ms.q) + BETA * overdueRatio;
  return {pi, p};
}

function pickBySoftmax(cands, now) {
  if (!cands.length) return null;
  const weights = cands.map(st => Math.exp(KAPPA * priorityOf(st, now).pi));
  const idx = softmaxSample(weights);
  return cands[idx];
}

// ---- Вероятность ввода новых ----
function newProbability(debtSize, coverage, targetNewShare) {
  const B_low = 20;  // порог «мало должников»
  const theta = 0.7;
  const kappa_c = 0.5;
  const partA = theta * clamp((B_low - debtSize) / B_low, 0, 1);
  const partB = kappa_c * clamp(targetNewShare - coverage, 0, 1);
  return clamp(partA + partB, 0, 1);
}

// ---- Публичная функция выбора следующей карточки ----
async function sampleNext(now = Date.now()) {
  if (!window.lexidb) throw new Error('cardengine: требуется window.lexidb');

  // 0) быстрый внутри-сессионный повтор, если готов
  const retry = pickupQuickRetry(now);
  if (retry) {
    // гарантируем, что статы существуют и intro установлен
    const st = await getStatsSafe(retry.id);
    if (!st.intro) await introduce(retry.id, now);
    return {termId: retry.id, mode: retry.mode};
  }

  // 1) собираем кандидатов
  const {due, nearly, totalIntro, totalTerms, allIntroStats} =
      await collectCandidates(now);
  const debt = due.length + nearly.length;

  // 2) ввод новых по вероятности
  const cov = (totalTerms === 0) ? 0 : (totalIntro / totalTerms);
  const pNew = newProbability(debt, cov, settings.targetNewShare);
  if (Math.random() < pNew) {
    const newIds = await window.lexidb.newTermIds();
    if (newIds.length) {
      const id = newIds[Math.floor(Math.random() * newIds.length)];
      await introduce(id, now);
      return {termId: id, mode: 'MC5'};
    }
  }

  // 3) пул due → softmax
  let chosen = null;
  if (due.length) {
    chosen = pickBySoftmax(due, now);
  } else if (nearly.length) {
    chosen = pickBySoftmax(nearly, now);
  } else if (allIntroStats.length) {
    // fallback: горячий пул из топ-приоритетов
    // сортируем по pi, берём верхние 30 и сэмплируем
    const ranked = allIntroStats.map(s => ({s, pr: priorityOf(s, now).pi}))
                       .sort((a, b) => b.pr - a.pr)
                       .slice(0, Math.min(30, allIntroStats.length))
                       .map(x => x.s);
    chosen = pickBySoftmax(ranked, now);
  }

  if (!chosen) {
    // вообще пусто (нет ни терминов, ни статов) — пробуем ввести новый, если
    // есть термы
    const newIds = await window.lexidb.newTermIds();
    if (newIds.length) {
      const id = newIds[Math.floor(Math.random() * newIds.length)];
      await introduce(id, now);
      return {termId: id, mode: 'MC5'};
    }
    throw new Error('cardengine: нет данных для показа');
  }

  // Возможное мягкое понижение stage при слабом q
  const stage = chosen.stage || 'MC5';
  const ms = stage === 'MC5' ? chosen.M :
      stage === 'CHUNKS'     ? chosen.C :
                               chosen.P;
  let mode = stage;
  if (ms.q <= Q_DOWN) {
    mode =
        (stage === 'COMPOSE') ? 'CHUNKS' : (stage === 'CHUNKS' ? 'MC5' : 'MC5');
  }

  return {termId: chosen.id, mode};
}

function carryForwardProgress(src, dst, now) {
  // переносим уверенность
  if (typeof src.q === 'number') dst.q = Math.max(dst.q ?? 0.5, src.q);
  // немного переносим интервал (чтобы новый режим не был совсем «нулёвым»)
  if (typeof src.S === 'number') dst.S = Math.max(dst.S ?? 0, src.S * 0.8);
  // небольшая «наследуемая» серия (макс 3), чтобы мягко ускорить закрепление
  dst.streak = Math.min(src.streak || 0, 3);
  // стартовые метки времени под текущую сессию
  dst.last = now;
  dst.due = now;  // хотим показать новый режим сразу
  // счётчик показов нового режима пока не трогаем — он должен расти с нуля
}

// ---- Переходы между режимами (по Settings) ----
function maybePromote(stats) {
  const stg = stats.stage || 'MC5';
  const now = Date.now();

  if (stg === 'MC5') {
    const m = stats.M, c = stats.C;
    const box = currentLeitnerBox(m.S);
    const ready = box >= settings.toCHUNKS.minBox &&
        (m.n || 0) >= settings.toCHUNKS.minShown &&
        (m.q || 0) >= settings.toCHUNKS.minAcc;
    const fast = (m.n || 0) >= 8 && (m.q || 0) >= 0.92;

    if (ready || fast) {
      carryForwardProgress(m, c, now);
      stats.stage = 'CHUNKS';
      return;
    }
  } else if (stg === 'CHUNKS') {
    const c = stats.C, p = stats.P;
    const box = currentLeitnerBox(c.S);
    const ready = box >= settings.toCOMPOSE.minBox &&
        (c.n || 0) >= settings.toCOMPOSE.minShown &&
        (c.q || 0) >= settings.toCOMPOSE.minAcc;
    const fast = (c.n || 0) >= 10 && (c.q || 0) >= 0.90;

    if (ready || fast) {
      carryForwardProgress(c, p, now);
      stats.stage = 'COMPOSE';
      return;
    }
  }
}

function maybeDemoteOnError(stats, mode) {
  // мягкое понижение stage (сохраняем прогресс режимов)
  const stg = stats.stage || 'MC5';
  const state = mode === 'MC5' ? stats.M :
      mode === 'CHUNKS'        ? stats.C :
                                 stats.P;
  if (state.q <= Q_DOWN) {
    if (stg === 'COMPOSE')
      stats.stage = 'CHUNKS';
    else if (stg === 'CHUNKS')
      stats.stage = 'MC5';
    // MC5 уже минимум
  }
}

// ---- Реакция на ответ пользователя ----
async function onReview(termId, mode, result, now = Date.now()) {
  if (!window.lexidb) throw new Error('cardengine: требуется window.lexidb');

  const s = await getStatsSafe(termId);
  const st = (mode === 'MC5' ? s.M : mode === 'CHUNKS' ? s.C : s.P);

  // время от последнего показа
  const dtDays = Math.max(1 / 1440, (now - st.last) / ONE_DAY);
  const p = pHat(dtDays, st.S);

  // адаптация шага на текущий апдейт
  const baseEta = ETA[mode] || 0.3;
  let eta = baseEta;
  if (st.streak >= 2 && result) eta *= (1 + 0.1 * Math.min(st.streak, 5));
  if (st.streak >= 2 && !result) eta *= 0.5;

  // обновление S в лог-пространстве
  const g = result ? (1 - p) : -(p + LAMBDA);
  const S_next = clipExp(Math.log(st.S) + eta * g, S_MIN, Smax());
  const due_next = dueFrom(now, S_next);

  // обновляем состояние
  st.S = S_next;
  st.last = now;
  st.due = due_next;
  st.q = (1 - RHO) * st.q + RHO * (result ? 1 : 0);
  st.streak = result ? (st.streak + 1) : 0;
  st.n = (st.n || 0) + 1;

  // продвижение/понижение stage
  if (result) {
    maybePromote(s);
  } else {
    maybeDemoteOnError(s, mode);
    // быстрый внутрисессионный повтор
    enqueueQuickRetry(termId, mode, now);
  }

  await window.lexidb.putStats(s);
}

// ---- Прогресс/метрики ----
async function getProgress(now = Date.now()) {
  const {due, nearly, totalIntro, totalTerms} = await collectCandidates(now);
  const coverage = (totalTerms === 0) ? 0 : (totalIntro / totalTerms);
  return {
    coverage,
    debt: due.length,
    nearly: nearly.length,
    totalIntro,
    totalTerms
  };
}

// ---- Экспорт API ----
const api = {
  configure,
  sampleNext,
  onReview,
  getProgress,
  getStatsSafe,
  introduce,
  version: '2.0.0-final'
};

if (typeof window !== 'undefined')
  window.cardengine = api;
else if (typeof globalThis !== 'undefined')
  globalThis.cardengine = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/widgets/dbStatistics.inline.js ===== */
(function() {
'use strict';

// --------- tiny utils ----------
const clamp01 = x => x < 0 ? 0 : x > 1 ? 1 : x;
const pct = x => Math.round(clamp01(x) * 100);
const fmtPct = x => `${pct(x)}%`;
const fmtAcc = x => (Math.round(clamp01(x) * 100) / 100).toFixed(2);  // 0.78

// one-time style injector
let styleInjected = false;
function injectStyle() {
  if (styleInjected) return;
  styleInjected = true;
  const css = `
:root{
  --card-bg: #ffffff;
  --card-elev: 0 10px 30px rgba(28,31,38,0.06);
  --text: #0f172a;
  --muted: #667085;
  --line: #e6e8f0;
  --ok: #22c55e;
  --ok-weak: #e8f8ef;
  --warn: #ef4444;
  --warn-weak: #fde8e8;
  --cov: #5b8cff;        /* coverage blue */
  --cov-weak:#e9efff;
  --track:#e9ecf2;
  --chip:#f3f4f6;
}
@media (prefers-color-scheme: dark){
  :root{
    --card-bg:#0f1117;
    --card-elev: 0 10px 30px rgba(0,0,0,0.35);
    --text:#e5e7eb;
    --muted:#98a2b3;
    --line:#1f2430;
    --track:#1f2430;
    --chip:#1a1f2e;
    --ok:#34d399;
    --ok-weak:#052e1c;
    --warn:#fb7185;
    --warn-weak:#33151b;
    --cov:#7aa2ff;
    --cov-weak:#0f1a3a;
  }
}
.dbstat[data-theme="light"]{
  --card-bg:#ffffff; --text:#0f172a; --muted:#667085; --line:#e6e8f0; --track:#e9ecf2; --chip:#f3f4f6;
  --ok:#22c55e; --ok-weak:#e8f8ef; --warn:#ef4444; --warn-weak:#fde8e8; --cov:#5b8cff; --cov-weak:#e9efff;
}
.dbstat[data-theme="dark"]{
  --card-bg:#0f1117; --text:#e5e7eb; --muted:#98a2b3; --line:#1f2430; --track:#1f2430; --chip:#1a1f2e;
  --ok:#34d399; --ok-weak:#052e1c; --warn:#fb7185; --warn-weak:#33151b; --cov:#7aa2ff; --cov-weak:#0f1a3a;
}

.dbstat{font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; color:var(--text);}
.dbstat *{box-sizing:border-box}

.dbstat.card{
  background:var(--card-bg);
  border-radius:20px;
  box-shadow:var(--card-elev);
  padding:18px 18px 22px;
}
.dbstat .hdr{
  font-weight:800; font-size:22px; letter-spacing:.2px; margin:2px 0 16px 4px;
}
.dbstat .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:0;}
.dbstat .cell{display:flex; flex-direction:column; align-items:center; padding:8px 0;}
.dbstat .cell + .cell{border-left:1px solid var(--line);}
.dbstat .label{font-size:14px; color:var(--muted); margin-bottom:6px;}
.dbstat .value{font-weight:900; font-size:36px; line-height:1;}
.dbstat .value.small{font-size:30px}
.dbstat .value .sub{font-weight:800; font-size:18px; color:var(--muted); margin-left:6px}
.dbstat .value.warn{color:var(--warn)}

.dbstat.compact{
  padding:10px 8px;
}
.dbstat .row{
  display:flex; align-items:center; gap:24px;
}
.dbstat .col{flex:1; min-width:180px}
.dbstat .sep{width:1px; height:30px; background:var(--line); opacity:.8}
.dbstat .bar{
  height:10px; width:100%; background:var(--track); border-radius:999px; position:relative; overflow:hidden;
}
.dbstat .bar > .fill{
  position:absolute; left:0; top:0; height:100%; width:0%; border-radius:999px; transition: width .6s ease;
}
.dbstat .pill{
  display:inline-flex; align-items:center; gap:8px;
  background:var(--chip); padding:8px 12px; border-radius:999px; font-weight:700;
}
.dbstat .k{font-weight:800; font-size:16px; margin-bottom:6px;}
.dbstat .acc .fill{ background: var(--ok); }
.dbstat .cov .fill{ background: var(--cov); }
.dbstat .debt{ color: var(--warn); }
.dbstat .muted{color:var(--muted)}
    `;
  const st = document.createElement('style');
  st.textContent = css;
  document.head.appendChild(st);
}

// ------- DOM builders ----------
function el(tag, className, text) {
  const e = document.createElement(tag);
  if (className) e.className = className;
  if (text != null) e.textContent = text;
  return e;
}

function buildCardRoot(theme) {
  injectStyle();
  const root = el('section', 'dbstat card');
  if (theme && theme !== 'auto') root.setAttribute('data-theme', theme);
  root.setAttribute('role', 'group');
  return root;
}

function buildCompactRoot(theme) {
  injectStyle();
  const root = el('section', 'dbstat compact');
  if (theme && theme !== 'auto') root.setAttribute('data-theme', theme);
  root.setAttribute('role', 'group');
  return root;
}

// --- renderers ---
function renderCard(root, s) {
  root.innerHTML = '';
  root.appendChild(el('div', 'hdr', 'Статистика по базе'));

  const grid = el('div', 'grid3');
  // Точность
  const c1 = el('div', 'cell');
  c1.appendChild(el('div', 'label', 'Точность'));
  const v1 = el('div', 'value');
  v1.textContent = fmtPct(s.avgAcc);
  c1.appendChild(v1);

  // Введено
  const c2 = el('div', 'cell');
  c2.appendChild(el('div', 'label', 'Введено'));
  const v2 = el('div', 'value');
  v2.innerHTML = `${s.entered}<span class="sub">/${s.total}</span>`;
  c2.appendChild(v2);

  // Долг
  const c3 = el('div', 'cell');
  c3.appendChild(el('div', 'label', 'Долг'));
  const v3 = el('div', 'value warn');
  v3.textContent = String(s.debt);
  c3.appendChild(v3);

  grid.appendChild(c1);
  grid.appendChild(c2);
  grid.appendChild(c3);
  root.appendChild(grid);
  return root;
}

function renderCompact(root, s) {
  root.innerHTML = '';
  const row = el('div', 'row');

  const col1 = el('div', 'col cov');
  const k1 = el('div', 'k');
  k1.innerHTML = `coverage <span class="muted">${fmtPct(s.coverage)}</span>`;
  const bar1 = el('div', 'bar');
  const fill1 = el('div', 'fill');
  fill1.style.width = `${pct(s.coverage)}%`;
  bar1.appendChild(fill1);
  col1.append(k1, bar1);

  const sep = el('div', 'sep');

  const col2 = el('div', 'col acc');
  const k2 = el('div', 'k');
  k2.innerHTML =
      `средняя точность <span class="muted">${fmtAcc(s.avgAcc)}</span>`;
  const bar2 = el('div', 'bar');
  const fill2 = el('div', 'fill');
  fill2.style.width = `${pct(s.avgAcc)}%`;
  bar2.appendChild(fill2);
  col2.append(k2, bar2);

  const debt = el('div', 'pill debt');
  debt.innerHTML = `<span class="muted">долг</span> <strong>${s.debt}</strong>`;

  row.append(col1, sep, col2, debt);
  root.appendChild(row);
  return root;
}

// ------- aggregator from TermStatsV2 ------
/**
 * Принимает массив TermStatsV2:
 * {
 *   id:string, stage:'MC5'|'CHUNKS'|'COMPOSE', intro:boolean,
 *   M:{q:number, due:number}, C:{q:number, due:number}, P:{q:number,
 * due:number}
 * }
 * Возвращает DbStats.
 * Логика:
 *  - coverage = entered / total;
 *  - avgAcc   = средний q по intro==true, берём q ведущего режима
 * (term[term.stage].q);
 *  - debt     = intro && (term[term.stage].due <= now) → считаем 1;
 */
function fromTermStats(list) {
  const total = list?.length || 0;
  const entered = list?.reduce((a, t) => a + (t?.intro ? 1 : 0), 0) || 0;

  let accSum = 0, accN = 0, debt = 0;
  const now = Date.now();
  if (list && list.length) {
    for (const t of list) {
      if (!t || !t.intro) continue;
      const st = (t.stage || 'MC5')[0];  // 'M'|'C'|'P'
      const mode = st === 'M' ? t.M : st === 'C' ? t.C : t.P;
      const q = (mode && typeof mode.q === 'number') ? mode.q : 0;
      accSum += q;
      accN++;
      const due = mode && typeof mode.due === 'number' ? mode.due : 0;
      if (due > 0 && due <= now) debt++;
    }
  }
  const avgAcc = accN ? (accSum / accN) : 0;
  const coverage = total ? (entered / total) : 0;
  return {coverage, avgAcc, debt, entered, total};
}

// ------- state & API -------
let _root = null;
let _variant = 'card';

function normalizeStats(s) {
  return {
    coverage: clamp01(Number(s?.coverage ?? 0)),
    avgAcc: clamp01(Number(s?.avgAcc ?? 0)),
    debt: Math.max(0, Math.trunc(Number(s?.debt ?? 0))),
    entered: Math.max(0, Math.trunc(Number(s?.entered ?? 0))),
    total: Math.max(0, Math.trunc(Number(s?.total ?? 0))),
  };
}

function mount(container, opts = {}) {
  const {variant = 'card', theme = 'auto', initial = null} = opts || {};
  _variant = variant;

  if (variant === 'compact') {
    _root = buildCompactRoot(theme);
    container.innerHTML = '';
    container.appendChild(_root);
    update(initial || {coverage: 0, avgAcc: 0, debt: 0, entered: 0, total: 0});
  } else {
    _root = buildCardRoot(theme);
    container.innerHTML = '';
    container.appendChild(_root);
    update(initial || {coverage: 0, avgAcc: 0, debt: 0, entered: 0, total: 0});
  }
  return _root;
}

function update(stats) {
  if (!_root) return;
  const s = normalizeStats(stats || {});
  if (_variant === 'compact')
    renderCompact(_root, s);
  else
    renderCard(_root, s);
}

// expose
window.dbStatistics = {
  mount,
  update,
  fromTermStats
};
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/widgets/keypad.inline.js ===== */
(() => {
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  function decideMask(len) {
    // Порядок ячеек: [0..5] = [TL, TM, TR, BL, BM, BR]
    if (len === 6) return [1, 1, 1, 1, 1, 1];
    if (len === 5) return [1, 1, 1, 1, 1, 0];  // нет верхней-левой
    if (len === 4) return [0, 1, 1, 0, 1, 1];  // правый 2×2
    if (len === 3) return [0, 1, 1, 0, 1, 0];  // L-shape (без BR)
    throw new Error('items length must be 3..6');
  }

  function cellsFromMask(mask) {
    // Вернём список видимых ячеек с координатами
    const pos = [
      {c: 0, r: 0, i: 0},
      {c: 1, r: 0, i: 1},
      {c: 2, r: 0, i: 2},
      {c: 0, r: 1, i: 3},
      {c: 1, r: 1, i: 4},
      {c: 2, r: 1, i: 5},
    ];
    return pos.filter(p => mask[p.i] === 1);
  }

  function readingOrder(mask) {
    // Порядок заполнения лейблов (слева-направо, сверху-вниз, пропуская пустые)
    const order = [0, 1, 2, 3, 4, 5];
    return order.filter(i => mask[i] === 1);
  }

  function has(mask, c, r) {
    if (c < 0 || c > 2 || r < 0 || r > 1) return 0;
    const idx = r * 3 + c;
    return mask[idx] ? 1 : 0;
  }

  // Определяем, какие углы плитки скруглять (только выпуклые)
  function cornerRadii(mask, c, r, radius) {
    const up = has(mask, c, r - 1);
    const down = has(mask, c, r + 1);
    const left = has(mask, c - 1, r);
    const right = has(mask, c + 1, r);

    const diagTL = has(mask, c - 1, r - 1);
    const diagTR = has(mask, c + 1, r - 1);
    const diagBL = has(mask, c - 1, r + 1);
    const diagBR = has(mask, c + 1, r + 1);

    // выпуклый угол = нет обоих ортогональных соседей И нет диагонального
    const tl = (!up && !left && !diagTL) ? radius : 0;
    const tr = (!up && !right && !diagTR) ? radius : 0;
    const bl = (!down && !left && !diagBL) ? radius : 0;
    const br = (!down && !right && !diagBR) ? radius : 0;

    return {tl, tr, bl, br};
  }

  // Внутренние разделители: генерируем только там, где по обе стороны есть
  // ячейки
  function buildSeparators(root, mask, tile, lineColor) {
    const makeLine = (x, y, w, h) => {
      const l = document.createElement('div');
      Object.assign(l.style, {
        position: 'absolute',
        left: x + 'px',
        top: y + 'px',
        width: w + 'px',
        height: h + 'px',
        background: lineColor,
        pointerEvents: 'none'
      });
      root.appendChild(l);
    };

    // Вертикальные швы между c|c+1
    for (let c = 0; c < 2; c++) {
      for (let r = 0; r < 2; r++) {
        if (has(mask, c, r) && has(mask, c + 1, r)) {
          const x = (c + 1) * tile;
          makeLine(x, r * tile, 1, tile);
        }
      }
    }
    // Горизонтальные швы между r|r+1
    for (let c = 0; c < 3; c++) {
      // одна горизонтальная граница между 0 и 1
      if (has(mask, c, 0) && has(mask, c, 1)) {
        const y = tile;
        makeLine(c * tile, y, tile, 1);
      }
    }
  }

  function styleText(el, textColor) {
    Object.assign(el.style, {
      position: 'absolute',
      inset: '0',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily:
          'Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial',
      fontWeight: '800',
      letterSpacing: '0.02em',
      color: textColor,
      userSelect: 'none',
      lineHeight: '1',
      padding: '6px',
      fontSize: '28px'
    });
  }

  function create(opts = {}) {
    const {
      mount = null,
      items = [],
      islandColor = '#F4F5F7',
      dividerColor = 'rgba(0,0,0, .14)',
      textColor = '#111',
      radius = 16,
      tile = 84,
      shadow = true,
      onSelect = () => {}
    } = opts;

    if (!Array.isArray(items) || items.length < 3 || items.length > 6) {
      throw new Error(
          'KeypadIsland: items must be an array of 3..6 short labels');
    }

    const mask = decideMask(items.length);
    const order = readingOrder(mask);
    const cells = cellsFromMask(mask);

    const root = document.createElement('div');
    root.className = 'keypad-island';
    const w = 3 * tile;
    const h = 2 * tile;
    Object.assign(root.style, {
      position: 'relative',
      width: w + 'px',
      height: h + 'px',
      // Никаких внешних границ; только мягкая тень, чтобы "поднять" остров
      filter: shadow ? 'drop-shadow(0px 4px 12px rgba(0,0,0,.20))' : 'none'
    });

    // Плитки
    let labelIdx = 0;
    for (const {c, r, i} of cells) {
      const cell = document.createElement('div');
      const x = c * tile, y = r * tile;
      Object.assign(cell.style, {
        position: 'absolute',
        left: x + 'px',
        top: y + 'px',
        width: tile + 'px',
        height: tile + 'px',
        background: islandColor,
        // Пер-угловые радиусы:
        borderTopLeftRadius: cornerRadii(mask, c, r, radius).tl + 'px',
        borderTopRightRadius: cornerRadii(mask, c, r, radius).tr + 'px',
        borderBottomLeftRadius: cornerRadii(mask, c, r, radius).bl + 'px',
        borderBottomRightRadius: cornerRadii(mask, c, r, radius).br + 'px',
        boxSizing: 'border-box',
        cursor: 'pointer'
      });

      const label = document.createElement('div');
      label.textContent = String(items[labelIdx++] ?? '');
      styleText(label, textColor);
      cell.appendChild(label);

      cell.addEventListener('click', (ev) => {
        const logicalIndex =
            order.indexOf(i);  // индекс элемента в текущем порядке
        onSelect(
            {index: logicalIndex, label: label.textContent, cell, event: ev});
      });

      root.appendChild(cell);
    }

    // Внутренние разделители (только между существующими парами)
    buildSeparators(root, mask, tile, dividerColor);

    // Монтирование
    if (mount) mount.appendChild(root);

    // Методы экземпляра
    const api = {
      el: root,
      update(next = {}) {
        // простая переинициализация (проще и надёжнее при inline)
        const parent = root.parentNode;
        if (parent) {
          parent.removeChild(root);
        }
        const merged = {
          mount: parent || mount,
          items: next.items ?? items,
          islandColor: next.islandColor ?? islandColor,
          dividerColor: next.dividerColor ?? dividerColor,
          textColor: next.textColor ?? textColor,
          radius: clamp(next.radius ?? radius, 0, 64),
          tile: clamp(next.tile ?? tile, 32, 200),
          shadow: next.shadow ?? shadow,
          onSelect: next.onSelect ?? onSelect
        };
        const newer = create(merged);
        // вернуть новый экземпляр наружу
        Object.assign(api, newer);
        return newer;
      },
      destroy() {
        if (root && root.parentNode) root.parentNode.removeChild(root);
      }
    };
    return api;
  }

  // Экспорт
  window.KeypadIsland = {create};
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/widgets/wordchoice.inline.js ===== */
(function() {
'use strict';

// ---- once-per-page style injection ----
const STYLE_ID = 'wci-inline-style';
const CSS = `
  .wci { position: relative; display: block; width: var(--wci-w, 600px);
         aspect-ratio: 10 / 6; border-radius: var(--wci-r,16px);
         background: var(--wci-bg, #F5F7FA); overflow: hidden; }
  /* минимальная «воздушная» тень, не рамка */
  .wci::after { content:''; position:absolute; inset:0; pointer-events:none;
                box-shadow: 0 4px 12px rgba(0,0,0,.08); }
  .wci-list { list-style: none; margin: 0; padding: 0; height: 100%;
              display: grid; grid-template-rows: repeat(5, 1fr); }
  .wci-item { position: relative; display: flex; align-items: center; justify-content: center;
              font: 700 24px/1.15 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
              color: var(--wci-text, #0A1428); letter-spacing: .2px; cursor: pointer;
              user-select: none; padding: .55em 1.2em; }
  /* Внутренние разделители — тонкие линии, доходят до краёв острова */
  .wci-item + .wci-item::before { content: ''; position: absolute; left: 0; right: 0; top: 0;
                                  height: 1px; background: var(--wci-div, #D7DFEA); }
  /* Ховер/фокус без внешней рамки */
  .wci-item:focus { outline: none; }
  .wci-item:is(:hover, :focus-visible) { background: color-mix(in oklab, var(--wci-bg,#F5F7FA) 90%, #000 10%); }
  .wci-item:active { transform: scale(0.996); }
  /* Доступность */
  .wci[role="listbox"] { outline: none; }
  .wci-item[aria-selected="true"] { background: color-mix(in oklab, var(--wci-bg,#F5F7FA) 80%, #000 20%); }
  @media (max-width: 480px) {
    .wci-item { font-size: 18px; }
  }`;

function injectStylesOnce() {
  if (document.getElementById(STYLE_ID)) return;
  const style = document.createElement('style');
  style.id = STYLE_ID;
  style.textContent = CSS;
  document.head.appendChild(style);
}

// ---- core factory ----
function createWordChoiceIsland(opts) {
  injectStylesOnce();

  const state = {
    items: normalizeItems(opts && opts.items),
    onSelect: (opts && opts.onSelect) || function() {},
    islandColor: (opts && opts.islandColor) || '#F5F7FA',
    dividerColor: (opts && opts.dividerColor) || '#D7DFEA',
    textColor: (opts && opts.textColor) || '#0A1428',
    width: (opts && opts.width) || 600,  // px
    radius: (opts && opts.radius) || 16,
    selected: -1
  };

  const root = document.createElement('div');
  root.className = 'wci';
  root.setAttribute('role', 'listbox');
  applyVars();

  const list = document.createElement('ul');
  list.className = 'wci-list';
  root.appendChild(list);

  renderItems();

  // keyboard navigation (Up/Down/Enter/Space)
  root.tabIndex = 0;
  root.addEventListener('keydown', (e) => {
    const max = 4;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      moveFocus(+1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      moveFocus(-1);
    } else if (e.key === 'Enter' || e.key === ' ') {
      const i = focusedIndex();
      if (i != null) activate(i);
    }
  });

  function applyVars() {
    root.style.setProperty('--wci-w', state.width + 'px');
    root.style.setProperty('--wci-r', state.radius + 'px');
    root.style.setProperty('--wci-bg', state.islandColor);
    root.style.setProperty('--wci-div', state.dividerColor);
    root.style.setProperty('--wci-text', state.textColor);
  }

  function normalizeItems(items) {
    const a = (Array.isArray(items) ? items : []).slice(0, 5);
    while (a.length < 5) a.push('');
    return a;
  }

  function renderItems() {
    list.innerHTML = '';
    state.items.forEach((label, i) => {
      const li = document.createElement('li');
      li.className = 'wci-item';
      li.setAttribute('role', 'option');
      li.setAttribute('aria-selected', String(state.selected === i));
      li.tabIndex = -1;
      li.textContent = String(label || '');
      li.addEventListener('click', () => activate(i));
      li.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          activate(i);
        }
      });
      list.appendChild(li);
    });
  }

  function activate(i) {
    state.selected = i;
    [...list.children].forEach(
        (el, idx) => el.setAttribute('aria-selected', String(idx === i)));
    state.onSelect(
        {index: i, value: state.items[i], element: list.children[i], root});
  }

  function focusedIndex() {
    const nodes = [...list.children];
    const idx = nodes.findIndex((n) => n === document.activeElement);
    return idx === -1 ? null : idx;
  }

  function moveFocus(dir) {
    const nodes = [...list.children];
    let idx = focusedIndex();
    if (idx == null)
      idx = dir > 0 ? 0 : nodes.length - 1;
    else
      idx = (idx + dir + nodes.length) % nodes.length;
    nodes[idx].focus();
  }

  // ---- public API ----
  const api = {
    el: root,
    mount(target) {
      (target || document.body).appendChild(root);
      return api;
    },
    updateItems(newItems) {
      state.items = normalizeItems(newItems);
      renderItems();
      return api;
    },
    updateColors({islandColor, dividerColor, textColor} = {}) {
      if (islandColor) state.islandColor = islandColor;
      if (dividerColor) state.dividerColor = dividerColor;
      if (textColor) state.textColor = textColor;
      applyVars();
      return api;
    },
    setWidth(px) {
      state.width = px;
      applyVars();
      return api;
    },
    setRadius(r) {
      state.radius = r;
      applyVars();
      return api;
    },
    select(i) {
      if (i >= 0 && i < 5) activate(i);
      return api;
    },
    get value() {
      return state.selected >= 0 ?
          {index: state.selected, value: state.items[state.selected]} :
          null;
    }
  };
  return api;
}

// expose globally
window.createWordChoiceIsland = createWordChoiceIsland;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/widgets/dbItemStatistics.inline.js ===== */
/* dbItemStatistics.inline.js — виджет показа статистики по одному терму
   Глобально экспортирует:
     window.dbItemStatistics = { create, update, format }
   Виджет не требует внешних стилей, использует Shadow DOM и CSS-переменные.

   Props:
   {
     term: string,                 // например: 'der Hand "-e'
     translations: string[]|string,// ['рука','кисть (руки)'] или строка с ;
     stats: TermStatsV2|{
       stage:'MC5'|'CHUNKS'|'COMPOSE',
       M:{S:number,last:number,due:number,q:number,streak:number},
       C:{S:number,last:number,due:number,q:number,streak:number},
       P:{S:number,last:number,due:number,q:number,streak:number},
       shown?: number
     },
     accentColor?: string,         // необязательно, переопределит --accent
     dangerColor?: string,         // необязательно, переопределит --danger
     onClick?: (ev)=>void          // клик по строке
   }
*/
(function() {
'use strict';

const CSS = `
:host, .root { box-sizing: border-box; }
* { box-sizing: inherit; }

:host { display:block; font: 500 16px/1.35 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }

.wrap {
  border-radius: 12px;
  padding: 12px 14px;
  cursor: default;
  user-select: none;
  background: var(--card, transparent);
  transition: background .15s ease, transform .05s ease;
}
.wrap.clickable { cursor: pointer; }
.wrap.clickable:active { transform: translateY(1px); }

.title {
  font-weight: 800;
  letter-spacing: .2px;
  font-size: 20px;
  color: var(--fg, #0f172a);
  margin: 0 0 4px 0;
}
.sub {
  color: var(--muted, #64748b);
  font-weight: 500;
  margin: 0 0 10px 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* блок с тремя колонками */
.stats {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  column-gap: 18px;
  align-items: start;
}
.col { position: relative; padding-left: 0; }
.col + .col { padding-left: 18px; }
.col + .col::before {
  content: "";
  position: absolute; left: 0; top: 4px; bottom: 4px;
  width: 1px; background: var(--border, rgba(100,116,139,.25));
}

.label {
  font-size: 13px;
  letter-spacing: .02em;
  color: var(--muted, #64748b);
  margin-bottom: 4px;
}
.value {
  font-size: 22px;
  font-weight: 900;
  color: var(--fg, #0f172a);
}
.value.accent { color: var(--accent, #16a34a); }
.value.danger { color: var(--danger, #e11d48); }

/* Ховер/фокус для кликабельных рядов */
.wrap.clickable:hover {
  background: color-mix(in srgb, var(--accent, #16a34a) 8%, transparent);
}
:host([data-theme="dark"]) .wrap.clickable:hover {
  background: color-mix(in srgb, var(--accent, #22c55e) 18%, transparent);
}

/* базовые переменные на случай отсутствия глобальной темы */
:host {
  --fg:           var(--app-fg, #0f172a);
  --muted:        var(--app-muted, #64748b);
  --border:       var(--app-border, rgba(100,116,139,.25));
  --accent:       var(--app-accent, #16a34a);
  --danger:       var(--app-danger, #e11d48);
  --card:         var(--app-card, transparent);
}
@media (prefers-color-scheme: dark) {
  :host {
    --fg:     var(--app-fg, #e5e7eb);
    --muted:  var(--app-muted, #9aa4b2);
    --border: var(--app-border, rgba(148,163,184,.28));
    --card:   var(--app-card, transparent);
  }
}
`;

// Нормализация входных данных
function asArray(x) {
  if (Array.isArray(x)) return x;
  if (x == null) return [];
  return String(x).split(';').map(s => s.trim()).filter(Boolean);
}

// Из TermStatsV2 достаём state активного режима
const modeKey = (stage) =>
    stage === 'MC5' ? 'M' : (stage === 'CHUNKS' ? 'C' : 'P');

function clamp(x, a, b) {
  return Math.min(b, Math.max(a, x));
}
function round2(x) {
  return Math.round(x * 100) / 100;
}

// Форматирование чисел
function fmtAcc(q) {
  if (q == null || Number.isNaN(q)) return '—';
  const v = clamp(q, 0, 1);
  // Для item-строки по макету — в диапазоне 0..1 с 2 знаками
  return String(round2(v).toFixed(2));
}
function fmtInt(n) {
  return (n == null || Number.isNaN(n)) ? '—' :
                                          String(Math.max(0, Math.trunc(n)));
}

// Создание DOM
function create(props) {
  const host = document.createElement('db-item-statistics');
  const shadow = host.attachShadow({mode: 'open'});

  // Позволяем локально переопределять цвета
  const style = document.createElement('style');
  style.textContent = CSS;

  const wrap = el('div', 'wrap');
  const title = el('h3', 'title');
  const sub = el('div', 'sub');

  const stats = el('div', 'stats');
  const c1 = metric('точность');
  const c2 = metric('верно подр.');
  const c3 = metric('показов');

  stats.appendChild(c1.col);
  stats.appendChild(c2.col);
  stats.appendChild(c3.col);

  wrap.appendChild(title);
  wrap.appendChild(sub);
  wrap.appendChild(stats);

  shadow.appendChild(style);
  shadow.appendChild(wrap);

  // Публичные ссылки на элементы для быстрого обновления
  host._els = {wrap, title, sub, c1, c2, c3};
  host._props = {};
  update(host, props || {});

  // Клик
  host._els.wrap.addEventListener('click', (ev) => {
    if (host._props && typeof host._props.onClick === 'function') {
      host._props.onClick(ev);
    }
  });

  return host;
}

// Вспомогательные построители
function el(tag, cls) {
  const d = document.createElement(tag);
  if (cls) d.className = cls;
  return d;
}
function metric(label) {
  const col = el('div', 'col');
  const l = el('div', 'label');
  l.textContent = label;
  const v = el('div', 'value');
  col.appendChild(l);
  col.appendChild(v);
  return {col, l, v};
}

// Рендер / обновление
function update(host, nextProps) {
  const props = Object.assign({}, host._props, nextProps || {});
  host._props = props;

  // term + translations
  host._els.title.textContent = String(props.term || '—');
  const tr = asArray(props.translations);
  host._els.sub.textContent = tr.join('; ');

  // Поддержка кликабельности
  if (props.onClick)
    host._els.wrap.classList.add('clickable');
  else
    host._els.wrap.classList.remove('clickable');

  // Цвета через инлайн-переменные (не ломают тему приложения)
  if (props.accentColor) host.style.setProperty('--accent', props.accentColor);
  if (props.dangerColor) host.style.setProperty('--danger', props.dangerColor);

  // Достаём state активного режима
  const st = (props.stats && props.stats.stage) ?
      props.stats[modeKey(props.stats.stage)] || {} :
      {};

  const q = st.q;
  const streak = st.streak;
  const shown = (props.stats && props.stats.shown);

  // Значения
  host._els.c1.v.textContent = fmtAcc(q);
  host._els.c2.v.textContent = fmtInt(streak);
  host._els.c3.v.textContent = fmtInt(shown);

  // Подсветка «долга» (ошибки приводят к низкой точности)
  host._els.c1.v.classList.toggle('danger', (q != null && q < 0.6));
  host._els.c1.v.classList.toggle('accent', (q != null && q >= 0.85));
}

// Экспортируемое форматирование (если нужно извне)
const format = {
  acc: fmtAcc,
  int: fmtInt
};

// Глобальный экспорт
window.dbItemStatistics = {
  create,
  update,
  format
};
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/home.inline.js ===== */
/* home.inline.js — экран Home (мобайл ~6.3")
   Зависимости: window.lexidb, window.dbStatistics, (опц.) window.util
   Экспорт: window.screens.home = { mount(container, opts), update(next?),
   destroy() }

   Поведение по ТЗ:
   - Вверху dbStatistics со всей БД.
   - Кнопки: «Импорт», «Добавить», «Экспорт», «База».
   - Кнопка «Проход» и строка «+ N −» не отображаются, если в базе нет
   элементов.
   - При +/− меняется число упражнений в проходе, сообщаем наружу
   onChangeRoundSize(n).
   - «Проход» вызывает onStartRound().
*/
(function() {
'use strict';

// -------- utils / fallbacks --------
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log = (U.log ? U.log('home') : (...a) => console.log('[home]', ...a));

function clamp(n, a, b) {
  return Math.max(a, Math.min(b, n));
}
function fmtPct01(x) {
  const v = Math.max(0, Math.min(1, +x || 0));
  return Math.round(v * 100) + '%';
}

async function importFromUrl(btn, url) {
  url = url || btn?.dataset?.url || '';
  if (!url) {
    log('ImportByLink: не задан URL');
    alert('Не задан URL для импорта');
    return;
  }

  const wasText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Импорт...';

  try {
    const resp = await fetch(url, {mode: 'cors', cache: 'no-store'});
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();

    const res = await window.lexidb.importText(text);
    await render();  // обновит карточку dbStatistics

    alert(
        `Импорт завершён:\n` +
        `+ добавлено: ${res.added}\n` +
        `~ обновлено: ${res.updated}\n` +
        `= пропущено: ${res.skipped}\n`);
    log('ImportByLink: success', res);
  } catch (e) {
    console.warn('[home] ImportByLink error', e);
    alert('Импорт не удался: ' + (e?.message || e));
  } finally {
    btn.disabled = false;
    btn.textContent = wasText;
  }
}
// -------- helpers: сбор агрегата для dbStatistics --------
async function computeDbStats() {
  try {
    await window.lexidb.open?.();
    const ids = await window.lexidb.listTermIds();
    const termsTotal = ids.length;
    if (termsTotal === 0) {
      return {
        hasData: false,
        stats: {coverage: 0, avgAcc: 0, debt: 0, entered: 0, total: 0}
      };
    }
    const stats = await Promise.all(ids.map(id => window.lexidb.getStats(id)));
    const list = [];
    for (let i = 0; i < ids.length; i++) {
      const s = stats[i];
      if (!s) continue;
      list.push({
        id: ids[i],
        stage: s.stage || 'MC5',
        intro: !!s.intro,
        M: {q: s.M?.q || 0, due: s.M?.due || 0},
        C: {q: s.C?.q || 0, due: s.C?.due || 0},
        P: {q: s.P?.q || 0, due: s.P?.due || 0}
      });
    }
    const agg = window.dbStatistics.fromTermStats(list);
    return {hasData: true, stats: agg};
  } catch (e) {
    console.warn('[home] computeDbStats error', e);
    return {
      hasData: false,
      stats: {coverage: 0, avgAcc: 0, debt: 0, entered: 0, total: 0}
    };
  }
}

// -------- view build --------
function build(container) {
  clear(container);

  const root = el('section', 'home');
  const wrap = el('div', 'wrap');

  // dbStatistics card
  const statsHost = el('div', 'block');
  const statsMount = document.createElement('div');
  statsHost.appendChild(statsMount);

  // actions
  const actions = el('div', 'grid4');
  const bImport = el('button', 'btn', 'Импорт');
  const bImport600 = el('button', 'btn', 'Импортировать 600 самых популярных');
  const bImportAll = el('button', 'btn', 'Импортировать всё (1200+)');
  const bAdd = el('button', 'btn', 'Добавить слово');
  const bExport = el('button', 'btn', 'Экспорт');
  const bDb = el('button', 'btn', 'База слов');
  actions.append(bImport, bAdd, bExport, bDb);

  // round size row
  const roundRow = el('div', 'round');
  const left = el('div', 'inc');
  const minus = el('button', 'icon', '−');
  const value = el('div', 'value', '—');
  const plus = el('button', 'icon', '+');
  left.append(minus, value, plus);
  const right = el('div');
  right.appendChild(el('div', 'hint', 'слов за раунд'));
  roundRow.append(left, right);

  // start button
  const bGo = el('button', 'btn primary', 'Поехали');

  // assemble
  wrap.append(
      statsHost, el('div', 'sp'), actions, el('div', 'sp'), roundRow,
      el('div', 'sp'), bGo, el('div', 'sp'), el('div', 'sp'), el('div', 'sp'),
      bImport600, el('div', 'sp'), bImportAll, el('div', 'footer'));
  root.appendChild(wrap);
  container.appendChild(root);

  return {
    root,
    wrap,
    statsMount,
    actions,
    bImport,
    bImport600,
    bImportAll,
    bAdd,
    bExport,
    bDb,
    roundRow,
    minus,
    plus,
    value,
    bGo
  };
}

// -------- state / API --------
const state = {
  mounted: false,
  els: null,
  opts: {},
  statsWidget: null,
  hasData: false,
  roundSize: 5
};

async function render() {
  // 1) статы
  const {hasData, stats} = await computeDbStats();
  state.hasData = hasData;

  if (!state.statsWidget) {
    state.statsWidget = window.dbStatistics.mount(
        state.els.statsMount, {variant: 'card', theme: 'auto', initial: stats});
  } else {
    window.dbStatistics.update(stats);
  }

  // 2) показать/скрыть «Проход» и «+ N −»
  state.els.roundRow.style.display = hasData ? '' : 'none';
  state.els.bGo.style.display = hasData ? '' : 'none';

  // 3) значение размера
  state.els.value.textContent = String(state.roundSize);

  log('stats', {
    coverage: fmtPct01(stats.coverage),
    avgAcc: stats.avgAcc?.toFixed?.(2) ?? '0.00',
    debt: stats.debt,
    entered: stats.entered,
    total: stats.total,
    hasData
  });
}

const api = {
  mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.opts = opts || {};
    state.roundSize = clamp(+opts.roundSize || 5, 2, 60);

    state.els = build(container);

    // actions → наружу
    state.els.bImport.addEventListener('click', () => {
      log('click Import');
      state.opts.onImport && state.opts.onImport();
    });
    state.els.bImport600.addEventListener('click', () => {
      log('click Import 600');
      importFromUrl(state.els.bImport600, 'nouns/600.txt');
    });
    state.els.bImportAll.addEventListener('click', () => {
      log('click Import ALL');
      importFromUrl(state.els.bImportAll, 'nouns/all.txt');
    });
    state.els.bAdd.addEventListener('click', () => {
      log('click Add');
      state.opts.onAdd && state.opts.onAdd();
    });
    state.els.bExport.addEventListener('click', () => {
      log('click Export');
      state.opts.onExport && state.opts.onExport();
    });
    state.els.bDb.addEventListener('click', () => {
      log('click DB');
      state.opts.onDb && state.opts.onDb();
    });

    // round control
    state.els.minus.addEventListener('click', () => {
      state.roundSize = clamp(state.roundSize - 1, 3, 60);
      state.els.value.textContent = String(state.roundSize);
      state.opts.onChangeRoundSize &&
          state.opts.onChangeRoundSize(state.roundSize);
      log('roundSize-', state.roundSize);
    });
    state.els.plus.addEventListener('click', () => {
      state.roundSize = clamp(state.roundSize + 1, 3, 60);
      state.els.value.textContent = String(state.roundSize);
      state.opts.onChangeRoundSize &&
          state.opts.onChangeRoundSize(state.roundSize);
      log('roundSize+', state.roundSize);
    });

    state.els.bGo.addEventListener('click', () => {
      log('start round', {n: state.roundSize});
      state.opts.onStartRound && state.opts.onStartRound(state.roundSize);
    });

    render();
  },

  update(next = {}) {
    if (!state.mounted) return;
    if (next && typeof next.roundSize === 'number') {
      state.roundSize = clamp(next.roundSize, 3, 60);
    }
    render();
  },

  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    if (state.els && state.els.root && state.els.root.parentNode) {
      state.els.root.parentNode.removeChild(state.els.root);
    }
    state.els = null;
    state.statsWidget = null;
    state.hasData = false;
    log('destroy');
  }
};

window.screens = window.screens || {};
window.screens.home = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/excercise.inline.js ===== */
/* excercise.inline.js — экран выполнения упражнения (MC5 / CHUNKS / COMPOSE)
   Модель: «толстый экран, простой роутер».
   Экран сам делает:
     - выбор следующей карточки (cardengine.sampleNext)
     - построение шагов и нормализацию опций (Keypad 3..6, WordChoice = 5)
     - обновление памяти (cardengine.onReview)
     - ведёт лог в консоль

   Зависимости (глобально):
     - window.lexidb
     - window.cardengine
     - window.lexiparts
     - window.KeypadIsland
     - window.createWordChoiceIsland
     - (опц.) window.util

   Экспорт:
     window.screens.excercise = {
       mount(container, opts),
       destroy()
     }

   opts:
     - progress?: { index:number, total:number } // "[2/5]" слева-сверху
     - seed?: number                              // детерминированные опции
     - termId?: string, mode?: 'MC5'|'CHUNKS'|'COMPOSE'  // (необязательно)
   принудительная карточка
     - onDone?: (payload) => void  // завершение упражнения:
         payload = {
           term, mode, success, errors,
           picks: { article, word?, chunks?, letters?, plural },
           correct: { article, word, chunks?, letters?, plural }
         }
*/

(function() {
'use strict';

// ---------- утилиты и фолбэки ----------
const U = window.util || {};
const log =
    (U.log ? U.log('exercise') : (...a) => console.log('[exercise]', ...a));
const el = U.el || ((tag, cls, text) => {
             const e = document.createElement(tag);
             if (cls) e.className = cls;
             if (text != null) e.textContent = text;
             return e;
           });
const clear = U.clear || (node => {
                while (node && node.firstChild)
                  node.removeChild(node.firstChild);
              });
const clamp = U.clamp || ((x, min, max) => Math.max(min, Math.min(max, x)));
const rndShuffle = (arr) =>
    arr.map(x => [Math.random(), x]).sort((a, b) => a[0] - b[0]).map(x => x[1]);

// ---------- состояние экрана ----------
const state = {
  mounted: false,
  container: null,
  root: null,
  // данные упражнения
  term: null,   // {id, art, de, pl, ru[]}
  mode: 'MC5',  // 'MC5'|'CHUNKS'|'COMPOSE'
  steps: [],    // [{type, options, correct, widget:'keypad'|'list', idx?}]
  stepIndex: 0,
  picks: {article: null, word: null, plural: null, chunks: [], letters: []},
  errors: 0,
  // DOM
  els: null,
  widget: null,  // текущий инстанс Keypad/WordChoice
  onDone: null
};

// ============================================================
// Генерация и НОРМАЛИЗАЦИЯ опций (главное правило: keypad 3..6)
// ============================================================

function pluralOptions(correct, k = 6) {
  // Список всех допустимых обозначений
  const ALL = [
    '-', '"-', '"-e', '-e', '-en', '"-en', '"-n', '-n', '-nen', '-s', '-er',
    '"-er'
  ];
  const uniq = (arr) => Array.from(new Set(arr));
  // эвристически добавим «родственные» вокруг correct
  const fam = {
    '-e': [
      '-', '-en', '-er', '"–e'.replace('–', '-')
    ],  // safety на случай копипаст
    '-en': ['-e', '"-en', '-'],
    '-nen': ['-en', '"-en', '-'],
    '-n': ['-e', '"-n', '-'],
    '"-e': ['"-', '"-en', '-e'],
    '"-en': ['"-', '"-e', '-en'],
    '"-n': ['"-', '"-e', '-n'],
    '-s': ['-', '-e'],
    '-er': ['-e', '"-er'],
    '"-er': ['-er', '"-e']
  };
  let pool = uniq([correct, ...(fam[correct] || []), ...ALL]);
  // к → 6, но не меньше 3
  let out = [];
  for (const x of pool) {
    if (!out.includes(x)) {
      out.push(x);
      if (out.length === k) break;
    }
  }
  if (out.length < Math.max(3, k)) {
    for (const x of ALL) {
      if (!out.includes(x)) {
        out.push(x);
        if (out.length === k) break;
      }
    }
  }
  // Гарантируем включение correct и длину 3..6
  if (!out.includes(correct)) out[0] = correct;
  if (out.length < 3) {
    while (out.length < 3) out.push('-');
  }
  return rndShuffle(out.slice(0, 5));
}

async function wordChoices(correctArt, correctDe, k = 5) {
  await window.lexidb.open?.();
  const terms = await window.lexidb.allTerms();
  const sameArt = terms.filter(t => t.art === correctArt && t.de !== correctDe)
                      .map(t => t.de);
  const rest = terms.filter(t => t.de !== correctDe).map(t => t.de);
  const pick = (arr, n) => rndShuffle(arr).slice(0, n);
  const uniqPush = (dst, src) => {
    const s = new Set(dst);
    for (const x of src) {
      if (!s.has(x)) dst.push(x);
    }
    return dst;
  };
  let distractors = pick(sameArt, k - 1);
  if (distractors.length < k - 1) {
    distractors =
        uniqPush(distractors, pick(rest, (k - 1) - distractors.length));
  }
  const all = uniqPush([correctDe], distractors);
  while (all.length < 5) all.push('');  // WordChoice сам подрежет/паддинг на 5
  return rndShuffle(all).slice(0, 5);
}

// Ключевая нормализация: гарантируем 3..6 элементов для keypad
function normalizeKeypadItems(stepType, correct, options, fallbackFactory) {
  let items = Array.isArray(options) ?
      options.map(x => String(x || '')).filter(Boolean) :
      [];
  // Гарантированное присутствие correct
  if (correct != null) {
    const s = String(correct);
    if (!items.includes(s)) items.unshift(s);
  }
  // Резка сверху
  if (items.length > 6) items = items.slice(0, 6);
  // Добор снизу, если нужно
  if (items.length < 3 && typeof fallbackFactory === 'function') {
    const fill = fallbackFactory();
    for (const v of fill) {
      if (items.length >= 6) break;
      const sv = String(v || '');
      if (sv && !items.includes(sv)) items.push(sv);
    }
  }
  // Минимальная страховка
  while (items.length < 3) items.push('•');
  return rndShuffle(items.slice(0, 6));
}

// ---------- планировщики шагов ----------
async function planForMC5(term) {
  const articleStep = {
    type: 'article',
    correct: term.art,
    options: normalizeKeypadItems('article', term.art, ['der', 'die', 'das']),
    widget: 'keypad'
  };
  const words = await wordChoices(term.art, term.de, 5);
  const wordStep =
      {type: 'word', correct: term.de, options: words, widget: 'list'};
  const pluralStep = {
    type: 'plural',
    correct: term.pl,
    options: normalizeKeypadItems(
        'plural', term.pl, pluralOptions(term.pl, 6),
        () => pluralOptions(term.pl, 6)),
    widget: 'keypad'
  };
  return [articleStep, wordStep, pluralStep];
}

async function planForChunks(term) {
  const steps = [];
  steps.push({
    type: 'article',
    correct: term.art,
    options: normalizeKeypadItems('article', term.art, ['der', 'die', 'das']),
    widget: 'keypad'
  });
  // чанки
  const chunks = window.lexiparts.splitChunks(term.de);
  const plan =
      await window.lexiparts.planChunks(term.de, 5);  // string[][] по шагам
  for (let i = 0; i < plan.length; i++) {
    const corr = chunks[i];
    const opts =
        normalizeKeypadItems('chunk', corr, plan[i], () => plan[i] || []);
    steps.push({
      type: 'chunk',
      idx: i,
      correct: corr,
      options: opts,
      widget: 'keypad'
    });
  }
  steps.push({
    type: 'plural',
    correct: term.pl,
    options: normalizeKeypadItems(
        'plural', term.pl, pluralOptions(term.pl, 6),
        () => pluralOptions(term.pl, 6)),
    widget: 'keypad'
  });
  return steps;
}

async function planForCompose(term) {
  const steps = [];
  steps.push({
    type: 'article',
    correct: term.art,
    options: normalizeKeypadItems('article', term.art, ['der', 'die', 'das']),
    widget: 'keypad'
  });
  const letters = window.lexiparts.splitCompose(term.de);
  const plan = await window.lexiparts.planCompose(term.de, 6);
  for (let i = 0; i < plan.length; i++) {
    const corr = letters[i];
    const opts =
        normalizeKeypadItems('letter', corr, plan[i], () => plan[i] || []);
    steps.push({
      type: 'letter',
      idx: i,
      correct: corr,
      options: opts,
      widget: 'keypad'
    });
  }
  steps.push({
    type: 'plural',
    correct: term.pl,
    options: normalizeKeypadItems(
        'plural', term.pl, pluralOptions(term.pl, 6),
        () => pluralOptions(term.pl, 6)),
    widget: 'keypad'
  });
  return steps;
}

// ---------- построение UI ----------
function buildUI(container, ruTitle, progress) {
  clear(container);

  const root = el('section', 'ex');
  const wrap = el('div', 'wrap');

  const prog =
      el('div', 'progress',
         progress ? `[${progress.index}/${progress.total}]` : '');
  const h1 = el('h1', null, (ruTitle || '').toUpperCase());
  wrap.append(prog, h1);

  const chips = el('div', 'chips');
  const chArt = makeChip('Артикль:', '—');
  const chWord = makeChip('Слово:', '—');
  const chPl = makeChip('Мн. ч.:', '—');
  chips.append(chArt.root, chWord.root, chPl.root);
  wrap.appendChild(chips);

  const mount = el('div', 'mount');
  wrap.appendChild(mount);

  const btnBack = el('button', 'btn-back', 'НАЗАД');
  btnBack.disabled = false;  // раньше было true
  btnBack.title = 'Назад';
  wrap.appendChild(btnBack);

  root.appendChild(wrap);
  container.appendChild(root);

  state.root = root;
  state.els = {wrap, prog, h1, chips, chArt, chWord, chPl, mount, btnBack};
  root.tabIndex = 0;
  setTimeout(() => root.focus(), 0);
}

function makeChip(label, value) {
  const root = el('div', 'chip');
  const sub = el('span', 'sub', label);
  const val = el('div', 'subCon', value);
  root.append(sub, val);
  return {
    root,
    set(v) {
      val.textContent = String(v == null ? '—' : v);
    }
  };
}

// ---------- прогресс/заголовки ----------
function updateChipsForMode() {
  const {chArt, chWord, chPl} = state.els;
  // Артикль
  chArt.set(state.picks.article || '—');

  // Слово: отображение зависит от режима/шага
  if (state.mode === 'MC5') {
    chWord.set(state.picks.word || '—');
  } else if (state.mode === 'CHUNKS') {
    const parts = state.picks.chunks.slice();
    const remaining =
        window.lexiparts.splitChunks(state.term.de).length - parts.length;
    const masked = parts.join('') +
        (remaining > 0 ? '•'.repeat(Math.max(1, remaining)) : '');
    chWord.set(masked || '•');
  } else {  // COMPOSE
    const letters = state.picks.letters.slice();
    const remaining =
        window.lexiparts.splitCompose(state.term.de).length - letters.length;
    const masked = letters.join('') +
        (remaining > 0 ? '•'.repeat(Math.max(1, remaining)) : '');
    chWord.set(masked || '•');
  }

  // Плюрал
  chPl.set(state.picks.plural || '—');
}
function getThemeVars(scope) {
  const cs = getComputedStyle(scope || document.documentElement);
  const bg = (cs.getPropertyValue('--ex-island-bg') || '').trim() || '#F4F5F7';
  const div =
      (cs.getPropertyValue('--ex-divider') || '').trim() || 'rgba(0,0,0,.14)';
  const text = (cs.getPropertyValue('--ex-text') || '').trim() || '#0A1428';
  return {bg, div, text};
}

// ---------- монтирование текущего шага ----------
function mountStep() {
  const s = state.steps[state.stepIndex];
  if (!s) {
    return;
  }
  const M = state.els.mount;
  // очистка предыдущего виджета
  if (state.widget && state.widget.destroy) try {
      state.widget.destroy();
    } catch (_) {
    }
  clear(M);

  const {bg, div, text} = getThemeVars(state.root);

  if (s.widget === 'list') {
    const widget = window.createWordChoiceIsland({
      items: s.options,
      islandColor: bg,
      dividerColor: div,
      textColor: text,
      width: Math.min(520, Math.floor(window.innerWidth - 24)),
      radius: 16,
      onSelect: ({index, value}) => handlePick(s, value)
    });
    widget.mount(M);
    state.widget = widget;
  } else {
    const widget = window.KeypadIsland.create({
      mount: M,
      items: s.options,
      islandColor: bg,
      dividerColor: div,
      textColor: text,
      radius: 16,
      tile: Math.max(
          80,
          Math.min(
              108,
              Math.floor((Math.min(520, window.innerWidth - 24)) / 3 - 4))),
      onSelect: ({label}) => handlePick(s, label)
    });
    state.widget = widget;
  }

  // кнопка назад активна, если уже есть сделанные шаги
  state.els.btnBack.disabled = (state.stepIndex === 0);
}

// ---------- обработчик выбора варианта ----------
function handlePick(step, value) {
  const correct = String(step.correct);
  const picked = String(value);
  const ok = (picked === correct);

  // сохраняем выбор в state.picks
  if (step.type === 'article') {
    state.picks.article = picked;
  } else if (step.type === 'word') {
    state.picks.word = picked;
  } else if (step.type === 'plural') {
    state.picks.plural = picked;
  } else if (step.type === 'chunk') {
    state.picks.chunks[step.idx] = picked;  // фиксируем позицию
  } else if (step.type === 'letter') {
    state.picks.letters[step.idx] = picked;
  }

  if (!ok) state.errors++;

  updateChipsForMode();

  // следующий шаг или завершение
  if (state.stepIndex < state.steps.length - 1) {
    state.stepIndex++;
    mountStep();
  } else {
    finishExercise();
  }
}

// ---------- кнопка «Назад» ----------
function attachBackHandler() {
  state.root.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      onBackClick();
    }
  });
  state.els.btnBack.addEventListener('click', onBackClick);
}

function onBackClick() {
  if (state.stepIndex <= 0) {
    try {
      state.onDone && state.onDone({aborted: true});
    } catch (_) {
    }
    // безопасно размонтируем экран и отправим домой
    try {
      window.app?.goHome?.();
    } catch (_) {
    }
    return;
  }
  // обычный шаг назад
  const step = state.steps[state.stepIndex - 1];
  recomputeErrorsUpTo(state.stepIndex - 1);
  if (step.type === 'article')
    state.picks.article = null;
  else if (step.type === 'word')
    state.picks.word = null;
  else if (step.type === 'plural')
    state.picks.plural = null;
  else if (step.type === 'chunk')
    state.picks.chunks = state.picks.chunks.slice(0, step.idx);
  else if (step.type === 'letter')
    state.picks.letters = state.picks.letters.slice(0, step.idx);

  state.stepIndex--;
  updateChipsForMode();
  mountStep();
}

function recomputeErrorsUpTo(lastIdx) {
  let errs = 0;
  for (let i = 0; i < lastIdx; i++) {
    const st = state.steps[i];
    const v = (() => {
      if (st.type === 'article') return state.picks.article;
      if (st.type === 'word') return state.picks.word;
      if (st.type === 'plural') return state.picks.plural;
      if (st.type === 'chunk') return state.picks.chunks[st.idx];
      if (st.type === 'letter') return state.picks.letters[st.idx];
      return null;
    })();
    if (String(v) !== String(st.correct)) errs++;
  }
  state.errors = errs;
}

// ---------- завершение упражнения ----------
async function finishExercise() {
  const correct = {
    article: state.term.art,
    word: state.term.de,
    plural: state.term.pl,
  };
  if (state.mode === 'CHUNKS') {
    correct.chunks = window.lexiparts.splitChunks(state.term.de);
  } else if (state.mode === 'COMPOSE') {
    correct.letters = window.lexiparts.splitCompose(state.term.de);
  }

  const success = (state.errors === 0);
  log('done:', {
    id: state.term.id,
    mode: state.mode,
    success,
    errors: state.errors,
    picks: state.picks
  });

  // обновляем память через cardengine (экран — единственная точка onReview)
  try {
    await window.cardengine.onReview(
        state.term.id, state.mode, success, Date.now());
  } catch (e) {
    console.error('[exercise] onReview failed', e);
  }

  // сообщаем наружу
  if (typeof state.onDone === 'function') {
    state.onDone({
      term: state.term,
      mode: state.mode,
      success,
      errors: state.errors,
      picks: JSON.parse(JSON.stringify(state.picks)),
      correct
    });
  }
}

// ---------- загрузка следующей карточки (или указанной) ----------
async function loadPayload(opts) {
  const progress = opts &&
      (opts.progress ?
           opts.progress :
           (typeof opts.index === 'number' && typeof opts.total === 'number' ?
                {index: opts.index, total: opts.total} :
                null));
  const seed = opts && typeof opts.seed === 'number' ? opts.seed : null;
  if (seed != null && window.lexiparts && window.lexiparts.setSeed)
    window.lexiparts.setSeed(seed);

  // получаем задачу
  let termId = opts && opts.termId;
  let mode = opts && opts.mode;
  if (!termId) {
    const pick = await window.cardengine.sampleNext(Date.now());
    termId = pick.termId;
    mode = pick.mode;
  }
  const term = await window.lexidb.getTerm(termId);
  if (!term) throw new Error('excercise: term not found by id=' + termId);

  state.term = term;
  state.mode = mode || 'MC5';
  state.picks =
      {article: null, word: null, plural: null, chunks: [], letters: []};
  state.errors = 0;
  state.steps = [];

  const ruTitle = (Array.isArray(term.ru) && term.ru[0]) ? term.ru[0] : term.de;
  buildUI(state.container, ruTitle, progress);
  attachBackHandler();

  // Предварительная маска словечка в CHUNKS/COMPOSE
  updateChipsForMode();

  // план (с нормализацией опций внутри планировщиков)
  if (state.mode === 'MC5')
    state.steps = await planForMC5(term);
  else if (state.mode === 'CHUNKS')
    state.steps = await planForChunks(term);
  else
    state.steps = await planForCompose(term);

  state.stepIndex = 0;
  mountStep();
}

// ---------- API ----------
const api = {
  async mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.container = container;
    state.onDone =
        opts.onDone || opts.onComplete || null;  // совместимость с роутером
    try {
      await window.lexidb.open?.();
      await loadPayload(opts);
      log('mounted', {id: state.term && state.term.id, mode: state.mode});
    } catch (e) {
      console.error('[exercise] mount error:', e);
      const fallback =
          el('div', null, 'Ошибка загрузки упражнения. Проверьте базу.');
      container.appendChild(fallback);
    }
  },
  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    if (state.widget && state.widget.destroy) try {
        state.widget.destroy();
      } catch (_) {
      }
    if (state.root && state.root.parentNode)
      state.root.parentNode.removeChild(state.root);
    state.container = null;
    state.root = null;
    state.els = null;
    state.widget = null;
    log('destroyed');
  }
};

window.screens = window.screens || {};
window.screens.excercise = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/roundResult.inline.js ===== */
/* roundResult.inline.js — экран результатов раунда
   Зависимости: (опционально) window.util (el/clear/log); есть фолбэки.

   Экспорт:
     window.screens.roundResult = {
       mount(container, {
         results,            // Array<ExerciseResult> из excerciseResult (см.
   там) completed,          // (опц.) число завершённых упражнений total, //
   (опц.) всего упражнений в раунде dbDeltaPp,          // (опц.) изменение
   средней точности БД в п.п. (+4/-2/0) onShowAll,          // (list) => void —
   показать все результаты по порядку onShowErrors        // (list) => void —
   показать только ошибочные по порядку
       }),
       update(next),
       destroy()
     }
*/
(function() {
'use strict';

// ---- утилиты/фолбэки ----
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log =
    (U.log ? U.log('roundResult') :
             (...a) => console.log('[roundResult]', ...a));
const clamp01 = x => x < 0 ? 0 : x > 1 ? 1 : x;

// ---- helpers ----
function pct(x) {
  return Math.round(clamp01(x) * 100);
}
function fmtPct(x) {
  return pct(x) + '%';
}

function build(container) {
  clear(container);

  const root = el('section', 'rr');
  const wrap = el('div', 'wrap');

  const card = el('section', 'card');
  const hdr = el('div', 'hdr', 'Результаты раунда');

  const grid = el('div', 'grid3');

  const c1 = el('div', 'cell');
  c1.append(el('div', 'label', 'Верно'));
  const v1 = el('div', 'value', '0');
  c1.append(v1);

  const c2 = el('div', 'cell');
  c2.append(el('div', 'label', 'Точность'));
  const v2 = el('div', 'value', '0%');
  const sub2 = el('span', 'sub', '');
  const box2 = el('div');
  box2.append(v2, sub2);  // держим вместе
  c2.append(box2);

  const c3 = el('div', 'cell');
  c3.append(el('div', 'label', 'Δ к БД (п.п.)'));
  const delta = el('div', 'delta flat', '0');
  c3.append(delta);

  grid.append(c1, c2, c3);
  card.append(hdr, grid);

  // Progress
  const progress = el('div', 'progress');
  const bar = el('div', 'bar');
  const fill = el('div', 'fill');
  bar.appendChild(fill);
  const bartext = el('div', 'bartext', '0 из 0 завершено');
  progress.append(bar, bartext);

  // CTAs
  const cta = el('div', 'cta');
  const bAll = el('button', 'btn primary', 'Смотреть все');
  const bErr = el('button', 'btn', 'Смотреть ошибки');
  cta.append(bAll, bErr);

  // Put together
  wrap.append(card, progress, cta, el('div', 'sp'));
  root.appendChild(wrap);
  container.appendChild(root);

  return {root, wrap, v1, v2, sub2, delta, fill, bartext, bAll, bErr};
}

function computeMetrics(results, completed, total) {
  const totalR = Array.isArray(results) ? results.length : 0;
  const tot = total ?? totalR;
  const comp = completed ?? totalR;

  const ok = (results || []).reduce((a, r) => a + (r && r.success ? 1 : 0), 0);
  const acc = tot > 0 ? ok / tot : 0;
  const errors = (results || []).filter(r => r && !r.success);
  return {ok, acc, comp, tot, errors};
}

// ---- state / API ----
const state = {
  mounted: false,
  els: null,
  container: null,
  opts: {}
};

function render() {
  const {results = [], completed, total, dbDeltaPp = 0} = state.opts;
  const {ok, acc, comp, tot, errors} =
      computeMetrics(results, completed, total);

  state.els.v1.textContent = String(ok);
  state.els.v2.textContent = fmtPct(acc);
  state.els.sub2.textContent = '';

  // Δ к БД
  const d = Math.round(+dbDeltaPp || 0);
  state.els.delta.textContent = (d > 0 ? '+' : '') + String(d);
  state.els.delta.className = 'delta ' +
      (d > 0     ? 'up' :
           d < 0 ? 'down' :
                   'flat');

  // Прогресс
  const p = (tot > 0) ? Math.max(0, Math.min(1, comp / tot)) : 0;
  state.els.fill.style.width = (p * 100).toFixed(0) + '%';
  state.els.bartext.textContent = `${comp} из ${tot} завершено`;

  // Кнопки
  if (errors.length === 0) {
    // преобразуем правую кнопку в "Далее"
    state.els.bErr.disabled = false;
    state.els.bErr.textContent = 'Далее';
    state.els.bErr.classList.add('primary');
    state.els.bErr.onclick = () => state.opts.onShowAll?.();
  } else {
    // Обычный режим: "Смотреть ошибки"
    state.els.bErr.disabled = false;
    state.els.bErr.textContent = 'Смотреть ошибки';
    state.els.bErr.onclick = () => state.opts.onShowErrors?.(errors.slice());
  }
  state.els.bAll.classList.remove('primary');
  state.els.bAll.onclick = () => {
    log('show all', {count: results.length});
    if (typeof state.opts.onShowAll === 'function')
      state.opts.onShowAll(results.slice());
  };
}

const api = {
  mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.container = container;
    state.opts = opts || {};
    state.els = build(container);
    render();
    log('mounted');
  },
  update(next = {}) {
    if (!state.mounted) return;
    state.opts = {...state.opts, ...next};
    render();
  },
  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    if (state.els && state.els.root && state.els.root.parentNode) {
      state.els.root.parentNode.removeChild(state.els.root);
    }
    state.els = null;
    state.container = null;
    state.opts = {};
    log('destroyed');
  }
};

window.screens = window.screens || {};
window.screens.roundResult = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/excerciseResult.inline.js ===== */
/* excerciseResult.inline.js — экран результата одного упражнения
   Зависимости:
     - window.lexidb         — для чтения статов
     - (опц.) window.util    — el/clear/log; есть фолбэки
     - (опц.) window.lexiparts — splitChunks/splitCompose (для показа масок при
   желании) Экспорт: window.screens.excerciseResult = { mount(container, {
         payload,            // { term, mode, success:boolean, errors:number,
   picks:{article,word?,plural, chunks?, letters?},
   correct:{article,word,plural,chunks?,letters?} } onNext,             // () =>
   void — тап по экрану onEdit              // (termId) => void — клик по
   "Редактировать"
       }),
       destroy()
     }

   Визуально и по сетке символов опирается на демо макет из /exRes_demo.html.
*/
(function() {
'use strict';

// ---- утилиты/фолбэки ----
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log =
    (U.log ? U.log('exResult') : (...a) => console.log('[exResult]', ...a));

// ---- helpers: форматирование/рендер ----
const toArr = (s) => Array.from(String(s ?? ''));
function joinAnswerFromPicks(p) {
  const word = p.word ??
      (Array.isArray(p.chunks) ?
           p.chunks.join('') :
           (Array.isArray(p.letters) ? p.letters.join('') : ''));
  return `${p.article ?? ''} ${word ?? ''} ${p.plural ?? ''}`.trim().replace(
      /\s+/g, ' ');
}
function joinCorrectFromObj(c) {
  const word = c.word ??
      (Array.isArray(c.chunks) ?
           c.chunks.join('') :
           (Array.isArray(c.letters) ? c.letters.join('') : ''));
  return `${c.article} ${word} ${c.plural}`.trim().replace(/\s+/g, ' ');
}
function fmtDue(ts) {
  if (!ts || typeof ts !== 'number') return '—';
  const now = Date.now(), one = 86400000;
  const d = Math.round((ts - now) / one);
  if (d === 0) return 'сегодня';
  if (d === 1) return 'завтра';
  if (d === -1) return 'вчера';
  return d > 0 ? `через ${d} дн` : `${Math.abs(d)} дн назад`;
}
function round(x, n = 2) {
  const k = 10 ** n;
  return Math.round(x * k) / k;
}

function renderRows(rootCorrect, rootAnswer, correct, answer) {
  const ref = toArr(correct);
  const usr = toArr(answer);
  const L = Math.max(ref.length, usr.length) || 1;

  rootCorrect.style.setProperty('--cols', L);
  rootAnswer.style.setProperty('--cols', L);

  clear(rootCorrect);
  clear(rootAnswer);

  for (let i = 0; i < L; i++) {
    const rc = ref[i] ?? ' ';
    const uc = usr[i] ?? ' ';

    const cCell = el('div', 'cell');
    const cCh = el('span', null, rc);
    cCell.appendChild(cCh);
    rootCorrect.appendChild(cCell);

    const aCell = el('div', 'cell ans ' + (uc === rc ? 'match' : 'error'));
    const aCh = el('span', null, uc);
    aCell.appendChild(aCh);
    rootAnswer.appendChild(aCell);
  }
}

// ---- построение UI ----
function build(container) {
  clear(container);

  const root = el('section', 'exres');
  const screen = el('div', 'screen');

  // top bar
  const top = el('div', 'top');
  const ttl = el('div', 'ttl', 'Результат');
  const badge = el('div', 'badge');
  const spacer = el('div');
  spacer.style.marginLeft = 'auto';
  const btnEdit = el('button', 'btn', '✎ Редактировать');
  top.append(ttl, badge, spacer, btnEdit);

  // term card
  const cardTerm = el('section', 'card');
  const h1 = el('h1', 'h1', '—');
  const gridC = el('div', 'grid mono');
  gridC.style.setProperty('--cols', '1');
  cardTerm.append(h1, gridC);

  // answer card
  const cardAns = el('section', 'card');
  const hint3 = el('div', 'hint', 'ваш ответ');
  const gridA = el('div', 'grid mono');
  gridA.style.setProperty('--cols', '1');
  const legend = el('div', 'legend');
  const dotOk = el('div', 'dot ok');
  const okLbl = el('span', 'sub', 'совпало');
  const dotEr = el('div', 'dot err');
  const erLbl = el('span', 'sub', 'ошибка');
  legend.append(dotOk, okLbl, dotEr, erLbl);
  cardAns.append(hint3, gridA, legend);

  // stats card
  const cardStat = el('section', 'card stat');
  const h3 = el('h3', null, 'Статистика по слову');
  const rowA = el('div', 'row2');
  const rowB = el('div', 'row2');
  const qBox = metric('q (EWMA)');
  const shownBox = metric('показов');
  const streakBox = metric('серия');
  const sBox = metric('S (дни)');
  const dueBox = metric('due');
  const stageWrap = el('div');
  stageWrap.style.display = 'flex';
  stageWrap.style.alignItems = 'center';
  stageWrap.style.justifyContent = 'flex-end';
  const stage = el('span', 'stage', 'режим: —');
  stageWrap.appendChild(stage);
  rowA.append(qBox.col, shownBox.col, streakBox.col);
  rowB.append(sBox.col, dueBox.col, stageWrap);
  cardStat.append(h3, rowA, rowB);

  const foot =
      el('p', 'foot', 'Тапните в любом месте, чтобы перейти к следующему');

  screen.append(top, cardTerm, cardAns, cardStat, foot);
  root.appendChild(screen);
  container.appendChild(root);

  return {
    root,
    screen,
    top,
    badge,
    btnEdit,
    h1,
    gridC,
    gridA,
    qBox,
    shownBox,
    streakBox,
    sBox,
    dueBox,
    stage
  };
}

function metric(label) {
  const col = el('div');
  const k = el('div', 'k', label);
  const v = el('div', 'v', '—');
  col.append(k, v);
  return {col, k, v};
}

// ---- состояние/экспорт ----
const state = {
  mounted: false,
  els: null,
  onNext: null,
  onEdit: null,
  payload: null
};

async function fill(els, payload) {
  const {term, mode, success, picks, correct} = payload;
  // Верхняя панель
  els.badge.className = 'badge ' + (success ? 'good' : 'bad');
  els.badge.textContent = success ? '✓ Верно' : '✕ Неверно';

  // Перевод
  const ru = Array.isArray(term.ru) ? term.ru[0] : (term.ru || '');
  els.h1.textContent = ru || term.de;

  // Готовим строки
  const correctStr = joinCorrectFromObj(correct);
  const answerStr = joinAnswerFromPicks(picks);

  // Гриды
  renderRows(els.gridC, els.gridA, correctStr, answerStr);

  // Статы текущего режима
  try {
    await window.lexidb.open?.();
    const st = await window.lexidb.getStats(term.id);
    if (st) {
      const key = mode === 'MC5' ? 'M' : (mode === 'CHUNKS' ? 'C' : 'P');
      const s = st[key] || {};
      els.qBox.v.textContent =
          (typeof s.q === 'number' ? (Math.round(s.q * 100) / 100).toFixed(2) :
                                     '—');
      els.streakBox.v.textContent = String(s.streak ?? '—');
      els.sBox.v.textContent =
          (typeof s.S === 'number' ? String(round(s.S, 1)) : '—');
      els.dueBox.v.textContent =
          (typeof s.due === 'number' ? fmtDue(s.due) : '—');
      // «показов»: берём n (счётчик предъявлений режима), если cardengine его
      // ведёт
      els.shownBox.v.textContent = String((s.n != null ? s.n : '—'));
      els.stage.textContent = 'режим: ' + (st.stage || mode || '—');
    }
  } catch (err) {
    console.error('[exResult] stats error', err);
  }
}

// ---- API ----
const api = {
  async mount(container, {payload, onNext, onEdit} = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.payload = payload;
    state.onNext = typeof onNext === 'function' ? onNext : null;
    state.onEdit = typeof onEdit === 'function' ? onEdit : null;

    const els = build(container);
    state.els = els;

    // Навигация
    els.btnEdit.addEventListener('click', (e) => {
      e.stopPropagation();
      if (state.onEdit) state.onEdit(payload.term.id);
    });
    // Тап по экрану — дальше
    els.screen.addEventListener('click', (e) => {
      if (e.target === els.btnEdit) return;
      if (state.onNext) state.onNext();
    });

    await fill(els, payload);
    log('mounted result', {id: payload.term.id, ok: payload.success});
  },

  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    if (state.els && state.els.root && state.els.root.parentNode) {
      state.els.root.parentNode.removeChild(state.els.root);
    }
    state.els = null;
    state.onNext = null;
    state.onEdit = null;
    state.payload = null;
    log('destroyed');
  }
};

window.screens = window.screens || {};
window.screens.excerciseResult = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/dbList.inline.js ===== */
/* dbList.inline.js — экран со списком всех слов из БД с фильтром
   Зависимости:
     - window.lexidb              (обязателен)
     - window.dbItemStatistics    (виджет одной строки)
     - (опц.) window.util         (el/clear/log), есть фолбэки

   Экспорт:
     window.screens.dbList = {
       mount(container, {
         onBack,          // () => void
         onOpen,          // (termId:string) => void   — тап по строке
         onDeleted        // () => void                — после очистки БД
       }),
       update(),          // перечитать БД и перерисовать
       destroy()
     }
*/
(function() {
'use strict';

// ---------- утилиты ----------
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log = (U.log ? U.log('dbList') : (...a) => console.log('[dbList]', ...a));

// ---------- helpers ----------
function formatTerm(t) {
  return `${t.art} ${t.de} ${t.pl}`;
}
function normalizeQuery(q) {
  return String(q || '').toLowerCase().trim();
}
function tokenMatch(hay, q) {
  if (!q) return true;
  const s = String(hay || '').toLowerCase();
  return s.includes(q);
}
function matches(term, q) {
  if (!q) return true;
  const toks = q.split(/\s+/).filter(Boolean);
  const base = [
    term.art, term.de, term.pl,
    ...(Array.isArray(term.ru) ? term.ru : [term.ru || ''])
  ].map(x => String(x || '').toLowerCase());
  return toks.every(tok => base.some(f => f.includes(tok)));
}
function sumShown(st) {
  return (+st?.M?.n || 0) + (+st?.C?.n || 0) + (+st?.P?.n || 0);
}

// ---------- DOM build ----------
function build(container) {
  clear(container);

  const root = el('section', 'dbl');
  const wrap = el('div', 'wrap');

  const top = el('div', 'top');
  const back = el('button', 'back', '←');
  const ttl = el('div', 'ttl', 'База слов');
  top.append(back, ttl);
  const sub = el('div', 'sub', 'все доступные для изучения слова');

  const search = el('div', 'search');
  const input = document.createElement('input');
  input.type = 'search';
  input.placeholder = 'Фильтр: артикль/слово/перевод…';
  search.appendChild(input);

  const list = el('div', 'list');

  wrap.append(top, sub, search, list);
  root.appendChild(wrap);
  container.appendChild(root);

  return {root, wrap, back, input, list};
}

// ---------- загрузка и рендер ----------
async function readAll() {
  await window.lexidb.open?.();
  const terms = await window.lexidb.allTerms();
  // читаем статы пачкой
  const stats = await Promise.all(terms.map(
      t => window.lexidb.getStats(t.id).then(
          s => s || window.lexidb.ensureStats(t.id))));
  // склеиваем
  const rows = terms.map((t, i) => ({term: t, stats: stats[i]}));
  // сортировка по слову
  rows.sort((a, b) => a.term.de.localeCompare(b.term.de, 'de'));
  return rows;
}

function renderRows(rows, q) {
  clear(state.els.list);

  // Кнопка «Удалить всё»
  const wipe = el('div', 'wipe');
  wipe.append(el('div', 'icon', '␡'), el('div', 'txt', 'Удалить всё'));
  wipe.addEventListener('click', onWipeAll);
  state.els.list.appendChild(wipe);

  let shown = 0;

  for (const {term, stats} of rows) {
    if (!matches(term, q)) continue;

    const s = Object.assign({}, stats || {});
    // добавим stage/shown (для виджета)
    s.shown = sumShown(stats);

    const row = window.dbItemStatistics.create({
      term: formatTerm(term),
      translations: term.ru || [],
      stats: s,
      onClick: () => {
        if (typeof state.opts.onOpen === 'function') state.opts.onOpen(term.id);
      }
    });

    state.els.list.appendChild(row);
    shown++;
  }

  if (shown === 0) {
    const empty = el('div', 'empty', 'Ничего не найдено. Измените запрос.');
    state.els.list.appendChild(empty);
  }
}

// ---------- очистка БД ----------
async function wipeAll() {
  // Полная очистка IndexedDB базы 'lexi.v2' (stores: 'terms', 'stats')
  // См. реализацию lexidb.inline.js (DB_NAME/STORE_TERMS/STORE_STATS).
  await new Promise((resolve, reject) => {
    const req = indexedDB.open('lexi.v2', 1);
    req.onerror = () => reject(req.error);
    req.onsuccess = () => {
      const db = req.result;
      const tx = db.transaction(['terms', 'stats'], 'readwrite');
      const stT = tx.objectStore('terms');
      const stS = tx.objectStore('stats');
      stT.clear();
      stS.clear();
      tx.oncomplete = () => resolve();
      tx.onabort = tx.onerror = () => reject(tx.error);
    };
  });
}

async function onWipeAll() {
  if (!confirm('Удалить все слова и статистику? Это действие нельзя отменить.'))
    return;
  try {
    await wipeAll();
    log('DB cleared');
    await api.update();
    if (typeof state.opts.onDeleted === 'function') state.opts.onDeleted();
  } catch (e) {
    console.error('[dbList] wipe error', e);
    alert('Не удалось очистить базу: ' + (e && e.message ? e.message : e));
  }
}

// ---------- state / API ----------
const state = {
  mounted: false,
  els: null,
  rows: [],
  opts: {}
};

const api = {
  async mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.opts = opts || {};
    state.els = build(container);

    state.els.back.addEventListener('click', () => {
      if (typeof state.opts.onBack === 'function') state.opts.onBack();
    });

    state.els.input.addEventListener('input', () => {
      const q = normalizeQuery(state.els.input.value);
      renderRows(state.rows, q);
    });

    await api.update();
    log('mounted');
  },

  async update() {
    if (!state.mounted) return;
    try {
      state.rows = await readAll();
      const q = normalizeQuery(state.els.input.value);
      renderRows(state.rows, q);
    } catch (e) {
      console.error('[dbList] update error', e);
      clear(state.els.list);
      state.els.list.appendChild(
          el('div', 'empty',
             'Ошибка чтения базы. Попробуйте перезагрузить страницу.'));
    }
  },

  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    const root = state.els && state.els.root;
    if (root && root.parentNode) root.parentNode.removeChild(root);
    state.els = null;
    state.rows = [];
    state.opts = {};
    log('destroyed');
  }
};

window.screens = window.screens || {};
window.screens.dbList = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/dbItemEdit.inline.js ===== */
/* dbItemEdit.inline.js — экран редактирования/удаления слова
   Зависимости:
     - window.lexidb
     - (опц.) window.util (el/clear/log)
   Экспорт:
     window.screens.dbItemEdit = {
       mount(container, {
         termId,        // string — id редактируемого терма
         onBack,        // () => void
         onSaved,       // (newId) => void
         onDeleted      // () => void
       }),
       destroy()
     }
*/
(function() {
'use strict';

// ---------- utils ----------
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log =
    (U.log ? U.log('dbItemEdit') : (...a) => console.log('[dbItemEdit]', ...a));

const ALLOWED_ART = new Set(['der', 'die', 'das']);
const ALLOWED_PL = new Set([
  '-', '"-', '"-e', '"-en', '-e', '-en', '"-n', '-n', '-nen', '-s', '-er',
  '"-er'
]);

const norm = s => String(s || '').replace(/\s+/g, ' ').trim();
function parseTermLine(line) {
  const parts = norm(line).split(' ');
  if (parts.length < 2) throw new Error('Слишком короткая term-строка');
  const art = String(parts[0]).toLowerCase().trim();
  if (!ALLOWED_ART.has(art))
    throw new Error('Недопустимый артикль (der/die/das)');
  const maybePl = parts[parts.length - 1];
  if (!ALLOWED_PL.has(maybePl))
    throw new Error(
        'В конце должен быть шаблон мн. числа (например, -e или "-er)');
  const de = norm(parts.slice(1, -1).join(' '));
  if (!de) throw new Error('Пустое слово (de)');
  return {art, de, pl: maybePl};
}
function parseRuLine(line) {
  const raw = String(line || '').trim().replace(/;+\s*$/, '');
  if (!raw) return [];
  return raw.split(';').map(s => s.trim()).filter(Boolean);
}
function applyUmlautOnce(stem) {
  const map = {a: 'ä', o: 'ö', u: 'ü'};
  let i = stem.toLowerCase().lastIndexOf('au');
  if (i >= 0) {
    const seg = stem.slice(i, i + 2);
    const repl = (seg[0] === seg[0].toUpperCase()) ? 'Äu' : 'äu';
    return stem.slice(0, i) + repl + stem.slice(i + 2);
  }
  let best = -1, v = '';
  for (const ch of ['a', 'o', 'u']) {
    const pos = stem.toLowerCase().lastIndexOf(ch);
    if (pos > best) {
      best = pos;
      v = ch;
    }
  }
  if (best >= 0) {
    const orig = stem[best], lo = orig.toLowerCase(), target = map[lo];
    const repl = (orig === orig.toUpperCase()) ? target.toUpperCase() : target;
    return stem.slice(0, best) + repl + stem.slice(best + 1);
  }
  return stem;
}
function pluralOf(base, pattern) {
  const needU = pattern.startsWith('"');
  const suf = pattern === '-' ? '' : pattern.replace(/^"?-?/, '');
  const stem = needU ? applyUmlautOnce(base) : base;
  return stem + suf;
}
function makeId({art, de, pl}) {
  return `${art} ${norm(de)} ${pl}`;
}

// ---------- view ----------
function build(container) {
  clear(container);
  const root = el('section', 'dbedit');
  const wrap = el('div', 'wrap');

  const head = el('div', 'head');
  const back = el('button', 'back', '←');
  const ttl = el('div', 'ttl', 'Редактировать');
  head.append(back, ttl);

  const card = el('section', 'card');
  const hint = el(
      'div', 'hint',
      'Блок импорта\n1-я строка: артикль + слово + мн. число; 2-я строка: переводы через ;');
  const ta = document.createElement('textarea');
  ta.className = 'ta';
  const err = el('div', 'err', '');
  err.style.display = 'none';
  const preview = el('div', 'preview');

  const row = el('div', 'row');
  const save = el('button', 'btn primary', 'Сохранить');
  save.disabled = true;
  const del = el('button', 'btn warn', 'Удалить');
  const cancel = el('button', 'btn ghost', 'Отмена');

  row.append(save, del);
  card.append(hint, ta, err, preview, row, cancel);

  wrap.append(head, card);
  root.appendChild(wrap);
  container.appendChild(root);

  return {root, wrap, back, ta, err, preview, save, del, cancel, ttl};
}

// ---------- DB actions ----------
async function readTerm(id) {
  await window.lexidb.open?.();
  const t = await window.lexidb.getTerm(id);
  if (!t) throw new Error('Терм не найден');
  return t;
}
async function writeTerm(oldId, next) {
  await window.lexidb.open?.();
  const oldStats = await window.lexidb.getStats(oldId);
  // put new term
  await window.lexidb.putTerm(next);
  const newId = next.id;
  // перенос статистики, если id поменялся
  if (newId !== oldId && oldStats) {
    const moved = Object.assign({}, oldStats, {id: newId});
    await window.lexidb.putStats(moved);
    // удалить старую запись stats
    await new Promise((resolve, reject) => {
      const req = indexedDB.open('lexi.v2', 1);
      req.onsuccess = () => {
        const db = req.result;
        const tx = db.transaction(['stats'], 'readwrite');
        tx.objectStore('stats').delete(oldId);
        tx.oncomplete = resolve;
        tx.onabort = tx.onerror = () => reject(tx.error);
      };
      req.onerror = () => reject(req.error);
    });
  }
  // если id изменился — удалить старый term
  if (newId !== oldId) {
    await new Promise((resolve, reject) => {
      const req = indexedDB.open('lexi.v2', 1);
      req.onsuccess = () => {
        const db = req.result;
        const tx = db.transaction(['terms'], 'readwrite');
        tx.objectStore('terms').delete(oldId);
        tx.oncomplete = resolve;
        tx.onabort = tx.onerror = () => reject(tx.error);
      };
      req.onerror = () => reject(req.error);
    });
  }
  return newId;
}
async function deleteTermWithStats(id) {
  await new Promise((resolve, reject) => {
    const req = indexedDB.open('lexi.v2', 1);
    req.onsuccess = () => {
      const db = req.result;
      const tx = db.transaction(['terms', 'stats'], 'readwrite');
      tx.objectStore('terms').delete(id);
      tx.objectStore('stats').delete(id);
      tx.oncomplete = resolve;
      tx.onabort = tx.onerror = () => reject(tx.error);
    };
    req.onerror = () => reject(req.error);
  });
}

// ---------- state / api ----------
const state = {
  mounted: false,
  els: null,
  opts: {},
  originalId: null
};

const api = {
  async mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.opts = opts || {};
    state.els = build(container);
    const {back, cancel, save, del} = state.els;

    back.addEventListener('click', () => {
      if (typeof state.opts.onBack === 'function') state.opts.onBack();
    });
    cancel.addEventListener('click', () => {
      if (typeof state.opts.onBack === 'function') state.opts.onBack();
    });

    // load
    try {
      const term = await readTerm(opts.termId);
      state.originalId = term.id;
      // prefill textarea
      const line1 = `${term.art} ${term.de} ${term.pl}`;
      const line2 =
          Array.isArray(term.ru) ? term.ru.join('; ') : String(term.ru || '');
      state.els.ta.value = `${line1}\n${line2}`;
      state.els.ttl.textContent = `Редактировать`;
    } catch (e) {
      state.els.ta.value = '';
      state.els.err.style.display = 'block';
      state.els.err.textContent =
          'Ошибка загрузки: ' + (e && e.message ? e.message : e);
    }

    function render() {
      try {
        const lines = String(state.els.ta.value || '')
                          .split(/\r?\n/)
                          .map(s => s.trim())
                          .filter(Boolean);
        if (lines.length < 1) throw new Error('Вставьте 2 строки по формату');
        const t = parseTermLine(lines[0]);
        const ru = parseRuLine(lines[1] || '');
        const plural = pluralOf(t.de, t.pl);
        state.els.preview.innerHTML =
            `<strong>Предпросмотр</strong><br>Слово: <b>${
                t.de}</b> • Артикль: <b>${t.art}</b><br>Мн. число: <b>${
                plural}</b><br>Переводы: ${ru.join('; ') || '—'}`;
        state.els.err.style.display = 'none';
        state.els.save.disabled = false;
      } catch (e) {
        state.els.err.textContent =
            'Ошибка формата — ' + (e && e.message ? e.message : e);
        state.els.err.style.display = 'block';
        state.els.preview.textContent = '';
        state.els.save.disabled = true;
      }
    }
    state.els.ta.addEventListener('input', render);
    render();

    save.addEventListener('click', async () => {
      try {
        const lines = String(state.els.ta.value || '')
                          .split(/\r?\n/)
                          .map(s => s.trim())
                          .filter(Boolean);
        const t = parseTermLine(lines[0]);
        const ru = parseRuLine(lines[1] || '');
        const id = makeId(t);
        const rec = {id, art: t.art, de: t.de, pl: t.pl, ru};
        const newId = await writeTerm(state.originalId, rec);
        state.originalId = newId;
        log('saved', newId);
        if (typeof state.opts.onSaved === 'function') state.opts.onSaved(newId);
      } catch (e) {
        alert('Не удалось сохранить: ' + (e && e.message ? e.message : e));
      }
    });

    del.addEventListener('click', async () => {
      if (!confirm('Удалить это слово и его статистику?')) return;
      try {
        await deleteTermWithStats(state.originalId);
        if (typeof state.opts.onDeleted === 'function') state.opts.onDeleted();
      } catch (e) {
        alert('Не удалось удалить: ' + (e && e.message ? e.message : e));
      }
    });

    log('mounted', {id: opts.termId});
  },

  destroy() {
    if (!state.mounted) return;
    const root = state.els?.root;
    if (root && root.parentNode) root.parentNode.removeChild(root);
    state.mounted = false;
    state.els = null;
    state.opts = {};
    state.originalId = null;
    log('destroyed');
  }
};

window.screens = window.screens || {};
window.screens.dbItemEdit = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/screens/dbItemAdd.inline.js ===== */
/* dbItemAdd.inline.js — экран добавления нового слова */
(function() {
'use strict';
const U = window.util || {};
const el = U.el || ((t, c, tx) => {
             const d = document.createElement(t);
             if (c) d.className = c;
             if (tx != null) d.textContent = tx;
             return d;
           });
const clear = U.clear || (n => {
                while (n && n.firstChild) n.removeChild(n.firstChild);
              });
const log =
    (U.log ? U.log('dbItemAdd') : (...a) => console.log('[dbItemAdd]', ...a));

const ALLOWED_ART = new Set(['der', 'die', 'das']);
const ALLOWED_PL = new Set([
  '-', '"-', '"-e', '"-en', '-e', '-en', '"-n', '-n', '-nen', '-s', '-er',
  '"-er'
]);

const norm = s => String(s || '').replace(/\s+/g, ' ').trim();
function parseTermLine(line) {
  const parts = norm(line).split(' ');
  if (parts.length < 2) throw new Error('Слишком короткая term-строка');
  const art = String(parts[0]).toLowerCase().trim();
  if (!ALLOWED_ART.has(art))
    throw new Error('Недопустимый артикль (der/die/das)');
  const maybePl = parts[parts.length - 1];
  if (!ALLOWED_PL.has(maybePl))
    throw new Error('В конце нужен шаблон мн. числа (например, -e или "-er)');
  const de = norm(parts.slice(1, -1).join(' '));
  if (!de) throw new Error('Пустое слово (de)');
  return {art, de, pl: maybePl};
}
function parseRuLine(line) {
  const raw = String(line || '').trim().replace(/;+\s*$/, '');
  if (!raw) return [];
  return raw.split(';').map(s => s.trim()).filter(Boolean);
}
function applyUmlautOnce(stem) {
  const map = {a: 'ä', o: 'ö', u: 'ü'};
  let i = stem.toLowerCase().lastIndexOf('au');
  if (i >= 0) {
    const seg = stem.slice(i, i + 2);
    const repl = (seg[0] === seg[0].toUpperCase()) ? 'Äu' : 'äu';
    return stem.slice(0, i) + repl + stem.slice(i + 2);
  }
  let best = -1, v = '';
  for (const ch of ['a', 'o', 'u']) {
    const pos = stem.toLowerCase().lastIndexOf(ch);
    if (pos > best) {
      best = pos;
      v = ch;
    }
  }
  if (best >= 0) {
    const orig = stem[best], lo = orig.toLowerCase(), target = map[lo];
    const repl = (orig === orig.toUpperCase()) ? target.toUpperCase() : target;
    return stem.slice(0, best) + repl + stem.slice(best + 1);
  }
  return stem;
}
function pluralOf(base, pattern) {
  const needU = pattern.startsWith('"');
  const suf = pattern === '-' ? '' : pattern.replace(/^"?-?/, '');
  const stem = needU ? applyUmlautOnce(base) : base;
  return stem + suf;
}
function makeId({art, de, pl}) {
  return `${art} ${norm(de)} ${pl}`;
}

function build(container) {
  clear(container);
  const root = el('section', 'dbadd');
  const wrap = el('div', 'wrap');
  const head = el('div', 'head');
  const back = el('button', 'back', '←');
  const ttl = el('div', 'ttl', 'Добавить слово');
  head.append(back, ttl);

  const card = el('section', 'card');
  const hint = el(
      'div', 'hint',
      'Блок импорта\n1-я строка: артикль + слово + мн. число\n2-я строка: переводы через ;');
  const ta = document.createElement('textarea');
  ta.className = 'ta';
  ta.placeholder = 'der Hand "-e\nрука; кисть (руки)';
  const err = el('div', 'err', '');
  const preview =
      el('div', 'preview', 'Предпросмотр появится при корректном формате');

  const row = el('div', 'row');
  const cancel = el('button', 'btn ghost', 'Отмена');
  const add = el('button', 'btn primary', 'Добавить');
  add.disabled = true;
  row.append(cancel, add);

  card.append(hint, ta, err, preview, row);
  wrap.append(head, card);
  root.appendChild(wrap);
  container.appendChild(root);
  return {root, wrap, back, ttl, ta, err, preview, add, cancel};
}

const state = {
  mounted: false,
  els: null,
  opts: {}
};

async function saveBlock(text) {
  await window.lexidb.open?.();
  const lines = String(text || '').split(/\r?\n/).map(s => s.trim());
  if (!lines[0]) throw new Error('Нет 1-й строки');
  const t = parseTermLine(lines[0]);
  const ru = parseRuLine(lines[1] || '');
  const id = makeId(t);
  const rec = {id, art: t.art, de: t.de, pl: t.pl, ru};
  await window.lexidb.putTerm(rec);
  await window.lexidb.ensureStats(id);  // на всякий
  return id;
}

function renderPreview() {
  const {ta, err, preview, add} = state.els;
  try {
    const lines = String(ta.value || '').split(/\r?\n/).map(s => s.trim());
    if (!lines[0]) {
      add.disabled = true;
      err.style.display = 'none';
      preview.textContent = '';
      return;
    }
    const t = parseTermLine(lines[0]);
    const ru = parseRuLine(lines[1] || '');
    const pl = pluralOf(t.de, t.pl);
    preview.innerHTML = `<strong>Предпросмотр</strong><br>Слово: <b>${
        t.de}</b> • Артикль: <b>${t.art}</b><br>Мн. число: <b>${
        pl}</b><br>Переводы: ${ru.join('; ') || '—'}`;
    err.style.display = 'none';
    add.disabled = false;
  } catch (e) {
    err.textContent = 'Ошибка формата — ' + (e?.message || e);
    err.style.display = 'block';
    add.disabled = true;
    preview.textContent = '';
  }
}

const api = {
  mount(container, opts = {}) {
    if (state.mounted) return;
    state.mounted = true;
    state.opts = opts || {};
    state.els = build(container);

    // чистые поля при каждом открытии
    state.els.ta.value = '';
    state.els.err.style.display = 'none';
    state.els.preview.textContent =
        'Предпросмотр появится при корректном формате';
    state.els.add.disabled = true;

    state.els.ta.addEventListener('input', renderPreview);
    state.els.back.addEventListener(
        'click', () => opts.onBack && opts.onBack());
    state.els.cancel.addEventListener(
        'click', () => opts.onBack && opts.onBack());

    state.els.add.addEventListener('click', async () => {
      try {
        const id = await saveBlock(state.els.ta.value);
        // reset формы после добавления
        state.els.ta.value = '';
        state.els.add.disabled = true;
        state.els.preview.textContent =
            'Предпросмотр появится при корректном формате';
        state.els.err.style.display = 'none';
        if (typeof opts.onAdded === 'function') opts.onAdded(id);
      } catch (e) {
        alert('Не удалось добавить: ' + (e?.message || e));
      }
    });

    renderPreview();
    log('mounted');
  },
  destroy() {
    if (!state.mounted) return;
    state.mounted = false;
    if (state.els?.root?.parentNode)
      state.els.root.parentNode.removeChild(state.els.root);
    state.els = null;
    state.opts = {};
    log('destroyed');
  }
};
window.screens = window.screens || {};
window.screens.dbItemAdd = api;
})();

/* ===== END JS ===== */

/* ===== BEGIN JS: src/js/app.js ===== */
/* app.js — корневой контроллер оффлайн-SPA с простым встроенным роутером
   Модель: «толстые экраны, простой роутер».
   Экран excercise сам делает sampleNext / onReview и следит за валидностью
   вариантов. Подключает экраны и модули:
   - screens: home, excercise, roundResult, excerciseResult, dbList, dbItemAdd,
   dbItemEdit
   - infra:   lexidb, cardengine, dbStatistics, util, widgets/*
*/
(function() {
'use strict';

// ---------- лог ----------
const log = (...a) => console.log('[app]', ...a);

// ---------- DOM-монтаж ----------
// В шаблоне используется <main id="root"> — монтируем именно сюда
const mountRoot = document.getElementById('root') ||
    document.getElementById('app') || document.body;

// ---------- настройки (LS) ----------
const LS_KEY = 'lexi.settings';
const defaults = {
  roundSize: 5
};
const settings = load();
function load() {
  try {
    return {...defaults, ...(JSON.parse(localStorage.getItem(LS_KEY)) || {})};
  } catch {
    return {...defaults};
  }
}
function save() {
  try {
    localStorage.setItem(LS_KEY, JSON.stringify(settings));
  } catch (_) {
  }
}

// ---------- единый лёгкий роутер ----------
const router = (() => {
  let state = {name: null, api: null};
  return {
    go(name, mountFn) {
      try {
        state.api?.destroy?.();
      } catch (e) {
        console.warn(e);
      }
      state = {name, api: null};
      const api = typeof mountFn === 'function' ? (mountFn() || null) : null;
      state.api = api;
      log('route →', name);
      return api;
    },
    reset() {
      try {
        state.api?.destroy?.();
      } catch (e) {
      }
      state = {name: null, api: null};
    },
    get name() {
      return state.name;
    },
    get api() {
      return state.api;
    }
  };
})();
window.router = router;  // опционально — удобно для отладки

// ---------- усреднённая точность БД (для Δ в roundResult) ----------
async function avgAccNow() {
  try {
    await window.lexidb.open?.();
    const ids = await window.lexidb.listTermIds();
    if (!ids.length) return 0;
    const stats = await Promise.all(ids.map(id => window.lexidb.getStats(id)));
    const list = [];
    for (let i = 0; i < ids.length; i++) {
      const s = stats[i];
      if (!s) continue;
      list.push({
        id: ids[i],
        stage: s.stage || 'MC5',
        intro: !!s.intro,
        M: {q: s.M?.q || 0, due: s.M?.due || 0},
        C: {q: s.C?.q || 0, due: s.C?.due || 0},
        P: {q: s.P?.q || 0, due: s.P?.due || 0}
      });
    }
    const agg = window.dbStatistics.fromTermStats(list);
    return +agg.avgAcc || 0;
  } catch (e) {
    console.warn('[app] avgAcc error', e);
    return 0;
  }
}

// ---------- импорт/экспорт ----------
async function doImport() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.txt,.md,text/plain';
  input.onchange = async () => {
    const file = input.files && input.files[0];
    if (!file) return;
    const txt = await file.text();
    await window.lexidb.open?.();
    const res = await window.lexidb.importText(txt);
    console.log('[import]', res);
    alert(`Импорт завершён:
+ добавлено: ${res.added}
* обновлено: ${res.updated}
= пропущено: ${res.skipped}
! ошибок: ${res.errors.length}`);
    if (router.name === 'home') window.screens.home?.update?.();
  };
  input.click();
}

let _exportBusy = false;
async function doExport() {
  if (_exportBusy) return;
  _exportBusy = true;
  try {
    await window.lexidb.open?.();
    const list = await window.lexidb.allTerms();
    const blocks = list.map(t => {
      const ru = Array.isArray(t.ru) ? t.ru.join('; ') : (t.ru || '');
      return `${t.art} ${t.de} ${t.pl}\n${ru}\n`;
    });
    const blob =
        new Blob([blocks.join('\n')], {type: 'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'lexi-export.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    // дать браузеру стартовать загрузку и освободить URL
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  } finally {
    // небольшой троттлинг, чтобы двойной клик не вызвал второй старт
    setTimeout(() => {
      _exportBusy = false;
    }, 400);
  }
}

// ---------- «сессия» раунда ----------
const session = {
  running: false,
  size: settings.roundSize,
  index: 0,
  results: [],
  baseAcc: 0
};
function resetSession(size) {
  session.running = true;
  session.size = size;
  session.index = 0;
  session.results = [];
}

// ---------- экраны ----------
function showHome() {
  router.go('home', () => {
    const api = window.screens.home;
    api.mount(mountRoot, {
      roundSize: settings.roundSize,
      onChangeRoundSize: (n) => {
        settings.roundSize =
            Math.max(3, Math.min(60, +n || defaults.roundSize));
        save();
        api.update({roundSize: settings.roundSize});
      },
      onStartRound: () => startRound(settings.roundSize),
      onDb: () => showDbList(),
      onAdd: () => showDbItemAdd(),
      onImport: () => doImport(),
      onExport: () => doExport()
    });
    (async () => {
      try {
        await window.lexidb.open?.();
        api.update();
      } catch (e) {
      }
    })();
    return api;
  });
}

async function startRound(size) {
  await window.lexidb.open?.();
  resetSession(size);
  session.baseAcc = await avgAccNow();
  log('round start', {size, baseAcc: session.baseAcc.toFixed(3)});
  nextExercise();
}

// ВАЖНО: роутер НЕ сэмплирует карточку и НЕ зовёт onReview — это делает
// «толстый» экран.
function nextExercise() {
  if (session.index >= session.size) {
    return finishRound();
  }
  router.go('excercise', () => {
    const ex = window.screens.excercise;
    ex.mount(mountRoot, {
      progress: {index: session.index + 1, total: session.size},  // опционально
      onDone: (payload) => {
        session.results.push(payload);
        session.index += 1;
        nextExercise();
      }
    });
    return ex;
  });
}

async function finishRound() {
  const after = await avgAccNow();
  const deltaPp = Math.round((after - session.baseAcc) * 100);  // п.п.
  showRoundResult(deltaPp);
}

function showRoundResult(deltaPp) {
  router.go('roundResult', () => {
    const rr = window.screens.roundResult;
    rr.mount(mountRoot, {
      results: session.results,
      completed: session.results.length,
      total: session.size,
      dbDeltaPp: deltaPp,
      onShowAll: (list) => startReviewSequence(list),
      onShowErrors: (list) => startReviewSequence(list)
    });
    return rr;
  });
}

// последовательный просмотр результатов и правки
const review = {
  list: [],
  idx: 0,
  deleted: new Set()
};

function startReviewSequence(list) {
  if (!Array.isArray(list) || list.length === 0)
    return startRound(settings.roundSize);
  review.list = list.slice();
  review.idx = 0;
  review.deleted = new Set();
  showOneResult();
}

function showOneResult() {
  const r = review.list[review.idx];
  if (!r) return startRound(settings.roundSize);
  router.go('excerciseResult', () => {
    const er = window.screens.excerciseResult;
    er.mount(mountRoot, {
      payload: r,
      canEdit: !review.deleted.has(r.termId),
      onNext: () => {
        review.idx += 1;
        showOneResult();
      },
      onEdit: (termId) => {
        showDbItemEdit(termId, {
          from: 'exres',
          onBack: () => showOneResult(),
          onSaved: () => showOneResult(),
          onDeleted: () => {
            review.deleted.add(termId);
            showOneResult();
          }
        });
      }
    });
    return er;
  });
}

function showDbList() {
  router.go('dbList', () => {
    const db = window.screens.dbList;
    db.mount(mountRoot, {
      onBack: () => showHome(),
      onOpen: (termId) => showDbItemEdit(termId, {from: 'list'}),
      onDeleted: () => {}
    });
    return db;
  });
}

function showDbItemAdd() {
  router.go('dbItemAdd', () => {
    const add = window.screens.dbItemAdd;
    add.mount(mountRoot, {onBack: () => showHome(), onAdded: () => showHome()});
    return add;
  });
}

function showDbItemEdit(termId, {from, onBack, onSaved, onDeleted} = {}) {
  router.go('dbItemEdit', () => {
    const ed = window.screens.dbItemEdit;
    ed.mount(mountRoot, {
      termId,
      onBack: () => {
        if (typeof onBack === 'function') return onBack();
        if (from === 'list') return showDbList();
        if (from === 'exres') return showOneResult();
        showHome();
      },
      onSaved: () => {
        if (typeof onSaved === 'function') onSaved();
      },
      onDeleted: () => {
        if (typeof onDeleted === 'function') onDeleted();
        if (from === 'list') return showDbList();
        if (from === 'exres') return showOneResult();
        showHome();
      }
    });
    return ed;
  });
}

// ---------- boot ----------
async function boot() {
  try {
    await window.lexidb.open?.();
    // Настройки движка карточек (экран сам ими пользуется)
    window.cardengine.configure?.({targetNewShare: 0.6, maxIntervalDays: 60});
    log('db ready');
  } catch (e) {
    console.error('[app] DB open failed', e);
  }
  showHome();
}

if (document.readyState === 'loading')
  document.addEventListener('DOMContentLoaded', boot, {once: true});
else
  boot();

// --- History glue (минимально) ---
window.addEventListener('popstate', (e) => {
  // простейший восстановитель: возвращаемся на home
  // (при желании можно хранить стек имен в state и восстанавливать точнее)
  showHome();
});

// пушим состояние на каждый показ экрана
const origGo = router.go;
router.go = function(name, mountFn) {
  const api = origGo(name, mountFn);
  try {
    history.pushState({name}, '', '#' + name);
  } catch (_) {
  }
  return api;
};

// Предупреждение при активном раунде
window.addEventListener('beforeunload', (e) => {
  if (session.running) {
    e.preventDefault();
    e.returnValue = '';
    return '';
  }
});


// expose for debug
window.app = {
  goHome: showHome,
  startRound: (n) => startRound(n || settings.roundSize),
  import: doImport,
  export: doExport,
  settings,
  router
};
})();

/* ===== END JS ===== */
    // ===== INLINE JS END =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>
</body>
</html>

